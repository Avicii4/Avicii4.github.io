<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Harry&#39;s Blog</title>
  
  <subtitle>Make it happen.</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-04-21T13:53:05.368Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Harry Chou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2022年苏州大学872考研回忆</title>
    <link href="http://yoursite.com/2022/03/29/exp/"/>
    <id>http://yoursite.com/2022/03/29/exp/</id>
    <published>2022-03-29T12:28:15.000Z</published>
    <updated>2022-04-21T13:53:05.368Z</updated>
    
    <content type="html"><![CDATA[<img src="/2022/03/29/exp/sign.jpg" class="" title="Photo by [Austin Chan](https:&#x2F;&#x2F;unsplash.com&#x2F;@austinchan?utm_source&#x3D;unsplash&amp;utm_medium&#x3D;referral&amp;utm_content&#x3D;creditCopyText) on [Unsplash](https:&#x2F;&#x2F;unsplash.com&#x2F;s&#x2F;photos&#x2F;success?utm_source&#x3D;unsplash&amp;utm_medium&#x3D;referral&amp;utm_content&#x3D;creditCopyText)"><blockquote><p>一年前，我在 <a href="http://scst.suda.edu.cn/">http://scst.suda.edu.cn/</a> 上看到了上一届的拟录取名单；一年后，我的名字也出现在了那里</p></blockquote><span id="more"></span><p>在经过几天等待之后，苏大官网终于公布拟录取名单，我以初复试<strong>总分第一</strong>的成绩被成功录取。略作庆祝后，想要记录下疫情下难忘的考研经历。这是一篇回忆和经验帖。（想直接看经验的，可直接进入“初试经验”板块）</p><p>我是2020年6月毕业的，当年8月底入职一家独角兽，但经过半个月试用期之后，意外被裁。我几乎没有犹豫就选择了考研，离职时工作交接、拿赔偿、走人一气呵成。因为我的家乡也在这边，同事里也有苏大的研究生，所以决定报考苏大。</p><h2 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h2><p>考研难吗？从我的结果来看，不难，我甚至都拉开对手好几十分；但从过程上看，很难。我是脱产在家备考的，一是不太相信自己的自制力，二是在家里独自复习，没有进度参照，没有人讨论题目，极易焦虑（我从8月东京奥运会闭幕后开始陷入紧张和焦虑）。如何克服负面情绪和影响复习的不利因素，是每个考研人的一笔精神收获。我当时也没有刻意逼迫自己，该学就学，该玩就玩：考试期间我炉石上了两次传说，把东京奥运会喜欢的项目都看了。憋坏了反而不好。不过，如果今天早上你起床，发现自己今天并不想学习，那也请你坐上书桌，试着学1个小时，如果今天大脑真是学不进去，再玩也不迟，很多时候你就是需要开个头。</p><p>控制手机使用方面，我是用的 <strong>Forest</strong> APP，它极大减少了我的屏幕时间，也可以记录我的学习时间。不过还是需要心态上保持 inner peace，否则换老年机里的贪食蛇你也能玩得飞起。</p><p><strong>专注力</strong>是复习中非常关键的因素，比如大家做数学经常粗心算错，导致无谓的失分，有可能就是专注力缺失造成的。比如你在课堂上望着窗外的景色，走神了整整一分钟，老师点名了你才反应过来：原来我刚刚走神了。这种走神时间很长，大家有意识；那如果只走神几秒钟呢？人很难察觉。而正是这几秒钟，你点错了小数点、少乘了一个 -1，就有了很多不应该的错误。我推荐大家进行一点<strong>冥想</strong>。现在所谓的冥想已经去掉了原本宗教的外壳，非常适合帮助大家集中注意力，调节好情绪和心态。详细的介绍可以去B站搜搜。我在复习后期进行数学模拟考时，每次都会冥想5~10分钟，随着练习量的增加，粗心的错误几乎没有了。（好像传销但不是）</p><h2 id="初试经验"><a href="#初试经验" class="headerlink" title="初试经验"></a>初试经验</h2><p>我从2021年3月10号正式开始复习。我是脱产在家复习的，没有其他事情干扰，前期一天学6小时，暑假开始加到8小时，后期10小时或更多。以下科目我都标明了自己的背景，也请大家在看各种经验贴的时候注意，别人的经验是否可以用到自己身上。</p><h3 id="政治"><a href="#政治" class="headerlink" title="政治"></a>政治</h3><p><strong>背景</strong>：光荣的团员（这门课大家确实都是零基础）</p><p>由于时间充裕，我在6月底开始看慢慢看徐涛老师的强化课，配合肖秀荣的《精讲精练》，不用担心适配的问题，书上没有的可以自己记笔记。看完课就整理一下，然后开始做《1000题》对应的选择题，这里建议打印一下答题表格，《1000题》是要反复刷至少两遍的，看完视频课之后就可以开始二刷了。我之后再针对错题做了三刷，这个大家看时间安排。</p><p>之后我看了腿姐的技巧班，主要学习选择题的关键词、技巧，和一些简答题答题经验、思路分析等等，这个也是我时间充裕所以全看了。然后就要开刷模拟题了，小程序或者实体书都刷，这里都是一些今年押题的知识点，所以需要牢记。肖八肖四必买，后关于<strong>背书</strong>，我跟着腿姐的公众号背的，其中马原肯定是全要背的，因为马原不好押题，今年只背肖四的人，到了考场第一道简答就只能自己硬编了。背书背的都是答题素材，到了考场还是要自己分析题干和材料的，这里我也去看了腿姐的冲刺班、押题班。事实证明，只默肖四得分不高。</p><p>我这里提到了很多视频课，时间不多的可以不看，巩固数学和专业课最重要。最终我的成绩也证明了，政治性价比不高，和别人拉开差距的往往不是这门课。不过字丑、写不清的同学需要练字，卷面整洁、字迹工整也是评分的一个角度。</p><h3 id="英语二"><a href="#英语二" class="headerlink" title="英语二"></a>英语二</h3><p><strong>背景</strong>：六级550+，喜爱英语，工作期间坚持背单词</p><p>我考了85。英语是每天都要背单词的，背了单词就不怕阅读文章。我真题买了黄皮书，从5月开始一点点刷从2001年开始的英语真题。</p><p><strong>阅读</strong>：配合的是唐迟的英语阅读课。客观评价，还行，让我知道了应试的基本思路，但很多具体的题目理解则无法说服我，因此我后来都是自己刷的阅读。阅读之前，还是推荐专注力不强的同学做一下冥想，一篇文章你就可以沉浸式地读完。后期模拟时，如果因为之前的句子太长，自己没有完全理解，也<strong>不要回读</strong>，因为具体做题时你肯定还要回来找答案细读的，这样可以加快速度。</p><p><strong>作文</strong>：也是首先建议大家练字，字母饱满、行文清晰即可，不一定非要衡水体。我用的王江涛的作文书，没有背，而是结合黄皮书的范文建立了自己的模板，然后拿真题不断练手，完善模板。考研英语作文我认为还是形式大于内容，即使你的议论角度新颖，但语言平庸俗气，显然分数不会高。作文平时注意积累，因此我从暑假开始，就注意阅读真题的文章里有没有我可以使用的搭配、句型，这样也不会花时间。</p><p><strong>翻译</strong>：唐静的翻译课很真诚，专注细节，跟着他的指导没问题。</p><p><strong>新题型</strong>：刘琦的课简单易懂，新题型基本也是被研究透的一种题型。</p><h3 id="数学二"><a href="#数学二" class="headerlink" title="数学二"></a>数学二</h3><p><strong>背景</strong>：高数全忘，高中数学还行</p><p>最终得分120+。基础好才是真的好。</p><p>先讲讲我的复习节奏和用书，我不太清楚怎么推荐老师和用书，我只能<strong>流水线</strong>讲述我的复习。3月开始复习数学，初期看汤家凤的基础课，整理自己的数学笔记，然后做《1800题》的入门训练。后来发现他的课内容非常少，不少知识点没有讲到，还要跑到微信公众号看寒假直播啥的，于是去看张宇的基础课（也全看了），再去做《1800题》的基础部分，并且二刷，复习数学笔记。之后强化阶段买了张宇的《18讲》，暑假开始看他的强化课，并且做他的《1000题》。我的评价是课很好，例题很好，但习题不算好。之后又多次复习《18讲》，拿张纸把他的例题答案遮住了不停刷。</p><p>5月我开始跟汤的线代基础，做《1800题》的基础部分。为什么没有一开始跟李永乐？因为我听了他基础班第一节课，发现跟不上，故选择了汤老师。之后我反正时间充裕，再把李永乐的基础线代课看完了，同期我也在做《660题》（此书线代太简单，不推荐强化的时候做），不要把高数扔了。线代强化我用李永乐的《线性代数讲义》，很稳。</p><p>学完后我就继续整体刷一遍《18讲》+《线性代数讲义》，并开始刷张八模拟卷。之后开始混着做真题（2006年开始）和模拟卷（包括李林、合工大）。我的评价是，2016年、2018年、2020年真题非常具有挑战性，目标在120的必须好好利用，制定自己三小时做不完的对策是什么，不至于上了考场手忙脚乱。而2022李林六的第一套也给了我这种感觉，非常逼真（逼近真题），今年的同学也可以做做。</p><p>—- 流水线结束—-</p><p>几点体会：</p><ol><li>什么题不会，就钻研那一部分，直到会为止；知识点有任何遗忘，立刻针对复习。关键词就是走出舒适区，不要只做自己会做的题。这个是痛苦时期，但熬过去基础会很扎实。</li><li>流水线里没提武忠祥老师，是因为已经没有很多时间去看他的完整课程，只是复习间穿插看的，但我对他视频课的评价最高，比如广义积分、中值定理，讲得非常透彻。觉得自己某一方面薄弱，也可以试着换个老师的课听听。</li><li>模拟题主要是模拟考场感觉，查漏补缺是辅助。每天早上八点半开始考试，到后期简直都麻木了。我最后的分数就是平时模拟的分数。</li><li>平时考研群里、B站总会有人拿些奇奇怪怪的题做文章，别浪费时间在这上面。</li><li>打草稿豪爽一点，我几次因为写的字太小太挤而做错。到了考场上，一般都是可以举手要的。</li></ol><h3 id="专业课872"><a href="#专业课872" class="headerlink" title="专业课872"></a>专业课872</h3><p><strong>背景</strong>：本科都学过，OS忘得比较厉害</p><p>最后得分110+。考完今年的试卷其实非常沮丧，题目和以往的真题有所差距，但我认为真题还是有意义的，不然你还有什么题可做？</p><p>数据结构，我一开始看王道的书，知识我大体都记得，只消注意细节。先是过一遍，把选择题做了，辅以一些王道的视频；再回过头复习，做了严蔚敏《数据结构》的习题，之后再是王道的代码题。我刷了两遍代码题，有些题理解起来是有点痛苦的，但还是那句话：走出舒适区。操作系统，也是先看的王道的书+视频，然后做题，我当时只做了选择题。之后开始看苏州大学的 MOOC，完成上边的作业和测试，熟悉苏大的套路。</p><p>之后我就开始做真题，真题答案很难搞到准确的，只能是自己摸索，并且去 MOOC 讨论区问老师，苏大老师还是非常有耐心的。从今年的试题情况来看，特别是OS部分，苏大和王道408的差距变大了，所以在<strong>完成以上任务以后</strong>，需要关注一下苏大给的OS参考书，就是三个美国人写的《操作系统概念》，包括课后习题；另外一本荷兰人写的《现代操作系统》（第4版），本书参考价值不如前一本，可在后期没题时看看。看了这些习题后，至少是有心理准备的。时间规划上，再次强调请<strong>量力而行</strong>，保证数学不掉链子是第一位的。</p><h2 id="复试经验"><a href="#复试经验" class="headerlink" title="复试经验"></a>复试经验</h2><p>Python 线上机试，主要还是跟着苏大的参考书认真敲代码，熟能生巧，我也做了一些笔记，可看我的另三篇文章。</p><p>自我介绍，中英文都要准备，对自己的口语很自信的朋友，这里就可以做英文介绍，给老师留个好印象。</p><p>计算机英语视译，我在提前准备这一项的时候专门找了英语国家的作者所写的论文，显然翻译起来难度会大一些。最终我所拿到的英文不算难，不存在状语、定语等的后置，根据原文顺序一溜翻译下来就行了。</p><p>最后是三个专业问题，也是面试中分数占比最大的，囊括范围极大。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/2022/03/29/exp/sign.jpg&quot; class=&quot;&quot; title=&quot;Photo by [Austin Chan](https:&amp;#x2F;&amp;#x2F;unsplash.com&amp;#x2F;@austinchan?utm_source&amp;#x3D;unsplash&amp;amp;utm_medium&amp;#x3D;referral&amp;amp;utm_content&amp;#x3D;creditCopyText) on [Unsplash](https:&amp;#x2F;&amp;#x2F;unsplash.com&amp;#x2F;s&amp;#x2F;photos&amp;#x2F;success?utm_source&amp;#x3D;unsplash&amp;amp;utm_medium&amp;#x3D;referral&amp;amp;utm_content&amp;#x3D;creditCopyText)&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;一年前，我在 &lt;a href=&quot;http://scst.suda.edu.cn/&quot;&gt;http://scst.suda.edu.cn/&lt;/a&gt; 上看到了上一届的拟录取名单；一年后，我的名字也出现在了那里&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="经验总结" scheme="http://yoursite.com/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记（三）</title>
    <link href="http://yoursite.com/2022/01/28/python-3/"/>
    <id>http://yoursite.com/2022/01/28/python-3/</id>
    <published>2022-01-28T08:39:12.000Z</published>
    <updated>2022-04-21T12:08:03.897Z</updated>
    
    <content type="html"><![CDATA[<img src="/2022/01/28/python-3/py3.jpg" class=""><h2 id="第六章-面向对象程序设计"><a href="#第六章-面向对象程序设计" class="headerlink" title="第六章 面向对象程序设计"></a>第六章 面向对象程序设计</h2><h3 id="1-定义与使用"><a href="#1-定义与使用" class="headerlink" title="1. 定义与使用"></a>1. 定义与使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:      <span class="comment"># 定义</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Car.&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">car = Car()     <span class="comment"># 实例化</span></span><br><span class="line">car.info()</span><br></pre></td></tr></table></figure><span id="more"></span><h4 id="2-1-self-参数"><a href="#2-1-self-参数" class="headerlink" title="2.1 self 参数"></a>2.1 self 参数</h4><p>类的所有实例方法都必须至少有一个self参数(未必命名为self)，且为第一个形参，代表着对象本身。在类的实例方法中<strong>访问实例属性</strong>需要以self为前缀，在<strong>外部通过对象名调用对象方法</strong>时不需要传递此参数。</p><h4 id="2-2-类成员与实例成员"><a href="#2-2-类成员与实例成员" class="headerlink" title="2.2 类成员与实例成员"></a>2.2 类成员与实例成员</h4><p>这里的成员也可以称为属性。</p><p><strong>类属性</strong>：在类中所有方法之外定义的数据成员。它属于类型，可通过类名或对象名访问。</p><p><strong>实例属性</strong>：一般在构造函数<code>__init__()</code>中定义，且定义时以self作为前缀。它属于实例（对象），只能通过对象名访问。</p><p>类的方法中可以调用类本身的其他方法，也可以动态地为类和对象增加成员。这是Python的一大特点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    price = <span class="number">100000</span>      <span class="comment"># 类属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, c</span>):</span><br><span class="line">        self.color = c  <span class="comment"># 实例属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">car_1 = Car(<span class="string">&#x27;Red&#x27;</span>)</span><br><span class="line">car_2 = Car(<span class="string">&#x27;Black&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(car_1.color, Car.price)</span><br><span class="line"><span class="built_in">print</span>(car_2.color, Car.price)</span><br><span class="line">Car.price = <span class="number">200000</span>       <span class="comment"># 修改类属性</span></span><br><span class="line">Car.name = <span class="string">&#x27;Audi&#x27;</span>        <span class="comment"># 增加类属性</span></span><br><span class="line">car_1.color = <span class="string">&#x27;White&#x27;</span> <span class="comment"># 修改实例属性</span></span><br><span class="line"><span class="built_in">print</span>(car_1.color, Car.price, Car.name)</span><br><span class="line"><span class="built_in">print</span>(car_2.color, Car.price, Car.name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_speed</span>(<span class="params">self, s</span>):</span><br><span class="line">    self.speed = s</span><br><span class="line"></span><br><span class="line">car_1.set_speed = types.MethodType(set_speed, Car)   <span class="comment"># 动态为对象car_1增加成员方法</span></span><br><span class="line">car_1.set_speed(<span class="number">60</span>)    <span class="comment"># car_2则没有这个方法</span></span><br><span class="line"><span class="built_in">print</span>(car_1.speed)</span><br></pre></td></tr></table></figure><blockquote><p>Python的函数与方法有区别，方法一般指与特定实例绑定的函数，通过对象调用方法时，对象本身被作为一个参数传递过去。普通函数不具此特点。</p></blockquote><h4 id="2-3-私有与共有成员"><a href="#2-3-私有与共有成员" class="headerlink" title="2.3 私有与共有成员"></a>2.3 私有与共有成员</h4><p>用两个下划线“__”表示私有属性，推荐只从对象的公有成员方法进行访问。公有属性可在类的内外部进行访问。</p><p>以下划线开头：</p><ul><li>_xxx，单下划线是保护成员，不能用 from … import xxx 访问， 只有类对象和子类对象可以访问</li><li>__xxx__，系统定义的特殊成员</li><li>__xxx，私有成员</li></ul><p>在IDLE等环境中，“_”表示解释器中最后一次显示的内容或最近一次结果。</p><h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2. 方法"></a>2. 方法</h3><p>私有方法以<code>__</code>开头，只能在属于对象的方法中以<code>self.xxx()</code>调用。公有方法通过对象名直接调用。</p><p>私有、公有方法用类名调用时，需要显示为该方法的self参数传递一个对象名，用于明确访问哪个对象的数据成员。</p><p>类方法和静态方法可以通过类名和对象名调用，不能访问属于对象的成员，只能访问属于类的成员。一般将<code>cls</code>作为类方法的第一个参数名称。(两者分别使用<code>@classmethod</code>, <code>@staticmethod</code> 来修饰)</p><h3 id="3-属性"><a href="#3-属性" class="headerlink" title="3. 属性"></a>3. 属性</h3><p>使用<code>@property</code> 或 <code>property()</code> 函数来声明一个属性。下面的代码中，属性可读、可修改、可删除：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span> (self, value):</span><br><span class="line">        self.__value = value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set</span>(<span class="params">self, v</span>):</span><br><span class="line">        self.__value = v</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">del</span> self.__value</span><br><span class="line">    </span><br><span class="line">    value = <span class="built_in">property</span>(__get, __<span class="built_in">set</span>,__<span class="keyword">del</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.__value)</span><br><span class="line">        </span><br><span class="line">t = Test(<span class="number">3</span>)</span><br><span class="line">t.value     <span class="comment"># 允许读</span></span><br><span class="line">t.value = <span class="number">5</span> <span class="comment"># 允许修改对象值</span></span><br><span class="line">t.show()    <span class="comment"># 可知属性值被修改</span></span><br></pre></td></tr></table></figure><p>删去三个函数中的某个，属性的读写性质就相应变化了。</p><h3 id="4-特殊方法"><a href="#4-特殊方法" class="headerlink" title="4. 特殊方法"></a>4. 特殊方法</h3><p>构造函数<code>__init__()</code>: 为数据成员设置初值或进行其他必要的初始化工作，创建对象时会被自动调用和执行。可通过为构造函数定义默认值参数来实现类似于其他语言中构造函数重载的目的。没有编写则提供默认。</p><p>析构函数<code>__del__()</code>：释放对象占用的资源，删除和收回对象空间时自动调用和执行。没有编写则python提供一个默认的析构函数。</p><table><thead><tr><th>方   法</th><th>说   明</th></tr></thead><tbody><tr><td>__new__()</td><td>类的静态方法，用于确定是否要创建对象</td></tr><tr><td>__add__()、__radd__()</td><td>左+、右+</td></tr><tr><td>__sub__()</td><td>-</td></tr><tr><td>__mul__()</td><td>*</td></tr><tr><td>__truediv__()</td><td>&#x2F;</td></tr><tr><td>__floordiv__()</td><td>&#x2F;&#x2F;</td></tr><tr><td>__mod__()</td><td>%</td></tr><tr><td>__pow__()</td><td>**</td></tr><tr><td>__eq__()、 __ne__()、__lt__()、 __le__()、__gt__()、 __ge__()</td><td>&#x3D;&#x3D;、 !&#x3D;、&lt;、 &lt;&#x3D;、&gt;、 &gt;&#x3D;</td></tr><tr><td>__lshift__()、__rshift__()</td><td>&lt;&lt;、&gt;&gt;</td></tr><tr><td>__and__()、__or__()、__invert__()、__xor__()</td><td>&amp;、|、~、^</td></tr><tr><td>__iadd__()、__isub__()</td><td>+&#x3D;、-&#x3D;，很多其他运算符也有与之对应的复合赋值运算符</td></tr><tr><td>__pos__()</td><td>一元运算符+，正号</td></tr><tr><td>__neg__()</td><td>一元运算符-，负号</td></tr><tr><td>__contains__()</td><td>与成员测试运算符in对应</td></tr></tbody></table><h3 id="5-继承机制"><a href="#5-继承机制" class="headerlink" title="5. 继承机制"></a>5. 继承机制</h3><p>派生类可以继承父类的公有成员，但不能继承其私有成员。在派生类中调用基类的方法可以使用<code>super()</code>或通过<code>基类名.方法名()</code>的方式实现。详情见以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):  <span class="comment"># 必须以object为基类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name=<span class="string">&#x27;&#x27;</span>, age=<span class="number">20</span>, sex=<span class="string">&#x27;male&#x27;</span></span>):</span><br><span class="line">        self.set_name(name)</span><br><span class="line">        self.set_age(age)</span><br><span class="line">        self.set_sex(sex)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_name</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(name, <span class="built_in">str</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;名字类型错误&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_age</span>(<span class="params">self, age</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(age, <span class="built_in">int</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;年龄类型错误&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.__age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_sex</span>(<span class="params">self, sex</span>):</span><br><span class="line">        <span class="keyword">if</span> sex != <span class="string">&#x27;male&#x27;</span> <span class="keyword">and</span> sex != <span class="string">&#x27;female&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;性别错误&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.__sex = sex</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Name:&#x27;</span>, self.__name)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Age:&#x27;</span>, self.__age)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Sex:&#x27;</span>, self.__sex)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>(<span class="title class_ inherited__">Person</span>):  <span class="comment"># 由Person派生</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name=<span class="string">&#x27;&#x27;</span>, age=<span class="number">20</span>, sex=<span class="string">&#x27;male&#x27;</span>, department=<span class="string">&#x27;CS&#x27;</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(Teacher, self).__init__(name, age, sex)</span><br><span class="line">        <span class="comment"># or  Person.__init__(self,name, age, sex)</span></span><br><span class="line">        self.__department = <span class="literal">None</span></span><br><span class="line">        self.set_department(department)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_department</span>(<span class="params">self, department</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(department, <span class="built_in">str</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;部门类型错误&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.__department = department</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Teacher, self).show()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Department:&#x27;</span>, self.__department)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    zhang = Person(<span class="string">&#x27;zhang&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;male&#x27;</span>)</span><br><span class="line">    zhang.show()</span><br><span class="line">    li = Teacher(<span class="string">&#x27;li&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;English&#x27;</span>)</span><br><span class="line">    li.show()</span><br><span class="line">    li.set_age(<span class="number">88</span>)</span><br><span class="line">    li.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>派生类没有定义<strong>构造方法</strong>时，创建派生类对象会调用父类的构造方法。<strong>父类构造方法</strong>无法调用派生类中<strong>重定义的私有方法</strong>，可以调用在派生类中重写的公有方法。</p><p>Python支持<strong>多继承</strong>，如果多个父类中有相同的方法名，而在子类中使用该方法时没有指定父类名，则解释器将从左向右按顺序搜索。例如 <code>Class Son(f1, f2)</code> 则先考虑调用f1类中的方法。</p><h2 id="第七章-文件操作"><a href="#第七章-文件操作" class="headerlink" title="第七章 文件操作"></a>第七章 文件操作</h2><h3 id="1-文件对象"><a href="#1-文件对象" class="headerlink" title="1. 文件对象"></a>1. 文件对象</h3><p><code>open()</code>函数可以以指定模式打开指定文件并创建文件对象，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fileobj = <span class="built_in">open</span>(文件名[, 打开方式[, 缓冲区]])</span><br></pre></td></tr></table></figure><p>其中，文件名默认寻找当前目录，否则要给出完整路径；打开方式各个模式见下表：</p><table><thead><tr><th>模   式</th><th>说   明</th></tr></thead><tbody><tr><td>r</td><td>读模式（常用rt，读取文本时会自动把\r\n转换成\n）</td></tr><tr><td>w</td><td>写模式（不存在就写，存在就覆盖）</td></tr><tr><td>a</td><td>追加模式</td></tr><tr><td>b</td><td>二进制模式（可与其它模式组合使用）</td></tr><tr><td>+</td><td>读写模式（可与其它模式组合使用）</td></tr><tr><td>w+</td><td>读写（存在则覆盖）</td></tr><tr><td>a+</td><td>读写（存在则追加）</td></tr></tbody></table><p>缓冲区有两种：数值0表示不缓存，数值1表示缓存（默认），大于1表示缓冲区大小</p><p>文件操作结束，一定要关闭文件以保存修改：<code>fileobj.close()</code></p><p><strong>文件对象属性</strong></p><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">closed</td><td align="left">判断文件是否关闭是则返回True</td></tr><tr><td align="left">mode</td><td align="left">返回文件的打开模式</td></tr><tr><td align="left">name</td><td align="left">返回文件的名称</td></tr></tbody></table><p><strong>文件对象常用方法</strong></p><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">flush()</td><td align="left">缓冲区写入文件，不关闭文件</td></tr><tr><td align="left">close()</td><td align="left">缓冲区写入文件，同时关闭文件，释放文件对象</td></tr><tr><td align="left">read([size])</td><td align="left">从文件中读取size个字符的内容作为结果返回，缺省一次读取所有的内容，<strong>支持中英文等不同字符</strong></td></tr><tr><td align="left">readline()</td><td align="left">从文本文件中读取一行内容 作为结果返回 <strong>(含换行符)</strong></td></tr><tr><td align="left">readlines()</td><td align="left">把文本文件中的每行文本作为一个字符串存入列表中，返回该列表 <strong>(含换行符)</strong></td></tr><tr><td align="left">seek(offset[,whence])</td><td align="left">把文件指针移动到新的位置（指定<strong>字节</strong>的位置），offset表示相对于whence的位置。whence为0表示从头开始，为1表示从当前位置开始，2表示从文件尾开始计算</td></tr><tr><td align="left">tell()</td><td align="left">返回指针的当前位置</td></tr><tr><td align="left">turncate([size])</td><td align="left">未指定size：删除从当前指针到文件末尾的内容，指定size：保留文件前size个字符，其余的删除</td></tr><tr><td align="left">write(s)</td><td align="left">把字符串s的内容写入文件</td></tr><tr><td align="left">writelines(s)</td><td align="left">把字符串列表写入文本文件，默认不添加换行符</td></tr></tbody></table><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><h4 id="2-1-上下文管理with"><a href="#2-1-上下文管理with" class="headerlink" title="2.1 上下文管理with"></a>2.1 上下文管理with</h4><p>上下文管理器<code>with</code>可以<strong>自动管理资源</strong>，任何原因跳出with块都会保证文件被正确关闭，并且可以在代码块结束后自动还原进入该代码块时的现场。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;demo.txt&#x27;</span>, <span class="string">&#x27;a+&#x27;</span>)</span><br><span class="line">s = <span class="string">&#x27;内容\nhaha&#x27;</span></span><br><span class="line">f.write(s)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于推荐写法：</span></span><br><span class="line">s = <span class="string">&#x27;内容\nhaha&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;de.txt&#x27;</span>, <span class="string">&#x27;a+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(s)</span><br></pre></td></tr></table></figure><h4 id="2-2-tell-与-seek"><a href="#2-2-tell-与-seek" class="headerlink" title="2.2 tell() 与 seek()"></a>2.2 tell() 与 seek()</h4><p>文件完成读写操作后，都会自动移动文件指针，在非UTF-8编码下，这两个函数均是针对于字节来说的（区别于<code>read()</code>函数），可能会出现隔断一个完整汉字而尝试读取的情况，此时会报错。建议始终在UTF-8编码下编程。</p><h4 id="2-3-二进制文件"><a href="#2-3-二进制文件" class="headerlink" title="2.3 二进制文件"></a>2.3 二进制文件</h4><p>二进制文件无法直接读取，其操作主要有pickle（推荐）、struct、json、marshal等模块。常用pickle：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">names = [<span class="string">&#x27;Jim&#x27;</span>, <span class="string">&#x27;Tony&#x27;</span>, <span class="string">&#x27;Tommy&#x27;</span>, <span class="string">&#x27;Jessica&#x27;</span>, <span class="string">&#x27;Anna&#x27;</span>]</span><br><span class="line">grades = [<span class="number">92</span>, <span class="number">66</span>, <span class="number">70</span>, <span class="number">88</span>, <span class="number">96</span>]</span><br><span class="line">dic = <span class="built_in">dict</span>(<span class="built_in">zip</span>(names, grades))</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;grade.dat&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    pickle.dump(dic, f)   <span class="comment"># 写入，第一个参数支持多种类型</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;写入异常&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;grade.dat&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(pickle.load(f))    <span class="comment"># 读取</span></span><br></pre></td></tr></table></figure><h3 id="3-文件级操作"><a href="#3-文件级操作" class="headerlink" title="3. 文件级操作"></a>3. 文件级操作</h3><p>处理文件路径：<code>os.path</code>模块<br>命令行读取文件内容：<code>fileinput</code>模块<br>创建临时文件：<code>tempfile</code>模块<br>表示和处理文件系统路径：<code>pathlib</code>模块</p><h4 id="3-1-os与os-path模块"><a href="#3-1-os与os-path模块" class="headerlink" title="3.1 os与os.path模块"></a>3.1 os与os.path模块</h4><p><strong>os模块常用文件操作方法</strong></p><table><thead><tr><th>方   法</th><th>说   明</th></tr></thead><tbody><tr><td>access(path, mode)</td><td>按照mode指定的权限访问文件（eg. mode&#x3D;0o777）</td></tr><tr><td>open(path, flags, mode, *,dir_fd)</td><td>按照mode指定的权限打开文件，默认权限为读写执行</td></tr><tr><td>chmod()</td><td>改变文件的访问权限</td></tr><tr><td>remove(path)</td><td>删除指定的文件</td></tr><tr><td>rename(src, dst)</td><td>重命名文件或目录，可以实现改名或移动</td></tr><tr><td>stat(path)</td><td>返回文件的所有属性</td></tr><tr><td>fstat(path)</td><td>返回打开的文件的所有属性</td></tr><tr><td>listdir(path)</td><td>返回path目录下的文件和目录列表</td></tr><tr><td>startfile(filepath[, operation])</td><td>使用关联的应用程序打开指定文件</td></tr></tbody></table><p><strong>os.path模块常用文件操作方法</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>abspath(path)</td><td>返回绝对路径</td></tr><tr><td>dirname(p)</td><td>返回目录的路径</td></tr><tr><td>exists(path)</td><td>判断文件是否存在</td></tr><tr><td>getatime(filename)</td><td>返回文件的最后访问时间</td></tr><tr><td>getctime(filename)</td><td>返回文件的最后创建时间</td></tr><tr><td>getmtime(filename)</td><td>返回文件的最后修改时间</td></tr><tr><td>getsize(filename)</td><td>返回文件的大小</td></tr><tr><td>isabs(path)</td><td>判断path是否为绝对路径</td></tr><tr><td>isdir(path)</td><td>判断path是否为目录</td></tr><tr><td>isfile(path)</td><td>判断path是否为文件</td></tr><tr><td>join(path, * paths)</td><td>连接两个或多个path</td></tr><tr><td>split(path)</td><td>对路径进行分割，以列表形式返回</td></tr><tr><td>splitext(path)</td><td>从路径中分割文件的扩展名</td></tr><tr><td>splitdrive(path)</td><td>从路径中分割驱动器的名称</td></tr><tr><td>walk(top, func, arg)</td><td>遍历目录</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">os.listdir(<span class="string">&#x27;.&#x27;</span>)   <span class="comment"># 当前目录下所有文件和目录的列表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>([fname <span class="keyword">for</span> fname <span class="keyword">in</span> os.listdir(os.getcwd()) <span class="keyword">if</span> os.path.isfile(fname) <span class="keyword">and</span> fname.endswith(<span class="string">&#x27;.py&#x27;</span>)])    <span class="comment"># 打印当前目录下以.py结尾的所有文件名列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量修改.txt为.html</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f_list=[fname <span class="keyword">for</span> fname <span class="keyword">in</span> os.listdir(os.getcwd()) <span class="keyword">if</span> os.path.isfile(fname) <span class="keyword">and</span> fname.endswith(<span class="string">&#x27;.txt&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f_list</span><br><span class="line">[<span class="string">&#x27;1.txt&#x27;</span>, <span class="string">&#x27;2.txt&#x27;</span>, <span class="string">&#x27;3.txt&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> f_list:</span><br><span class="line"><span class="meta">... </span>    newname = i[:-<span class="number">4</span>]+<span class="string">&#x27;.html&#x27;</span></span><br><span class="line"><span class="meta">... </span>    os.rename(i,newname)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i+<span class="string">&#x27;更名为：&#x27;</span>+newname)</span><br><span class="line"><span class="number">1.</span>txt更名为：<span class="number">1.</span>html</span><br><span class="line"><span class="number">2.</span>txt更名为：<span class="number">2.</span>html</span><br><span class="line"><span class="number">3.</span>txt更名为：<span class="number">3.</span>html</span><br></pre></td></tr></table></figure><h4 id="3-2-shutil模块"><a href="#3-2-shutil模块" class="headerlink" title="3.2 shutil模块"></a>3.2 shutil模块</h4><p><code>import shutil</code>之后用<code>dir(shutil)</code>查看文档</p><p><code>copyfile(path1, path2)</code>：复制文件；</p><p><code>make_archive()</code>, <code>unpack_archive()</code>：压缩与解压锁</p><p><code>shutil.rmtree()</code>：删除文件夹</p><h3 id="4-目录操作"><a href="#4-目录操作" class="headerlink" title="4. 目录操作"></a>4. 目录操作</h3><p><strong>os模块常用目录操作方法与成员</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>mkdir(path[, mode&#x3D;0777])</td><td>创建目录</td></tr><tr><td>makedirs(path1&#x2F;path2…, mode&#x3D;511)</td><td>创建多级目录</td></tr><tr><td>rmdir(path)</td><td>删除目录</td></tr><tr><td>rmvedirs(path)</td><td>删除多级目录</td></tr><tr><td><strong>listdir(path)</strong></td><td>返回指定目录下的文件和目录信息</td></tr><tr><td><strong>getcwd()</strong></td><td>返回当前工作目录</td></tr><tr><td>get_exec_path()</td><td>返回可执行文件的搜索路径</td></tr><tr><td><strong>chdir(path)</strong></td><td>把path设为当前的工作目录</td></tr><tr><td>walk(top, topdown&#x3D;True, onerror&#x3D;None)</td><td>遍历目录树，该方法返回一个元组，包含3个元素：所有路径名，所有目录列表，文件列表。参数topdown的默认值是”True”,表示首先返回目录树下的文件，然后在遍历目录树的子目录；值为”False”时，则表示先遍历目录树的子目录，返回子目录下的文件，最后返回根目录下的文件</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># walk() 遍历指定目录下的所有文件及子目录</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">&quot;.&quot;</span>, topdown=<span class="literal">False</span>):</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> files:</span><br><span class="line">        <span class="built_in">print</span>(os.path.join(root, name))</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> dirs:</span><br><span class="line">        <span class="built_in">print</span>(os.path.join(root, name))</span><br></pre></td></tr></table></figure><h2 id="第八章-异常处理"><a href="#第八章-异常处理" class="headerlink" title="第八章 异常处理"></a>第八章 异常处理</h2><p>异常处理不应该代替常规的程序检查如<code>if...else...</code></p><p>可以通过继承Python内置的异常类来自定义异常类，通过继承相同基类而细分相关的异常。</p><h3 id="1-结构"><a href="#1-结构" class="headerlink" title="1. 结构"></a>1. 结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    do something</span><br><span class="line"><span class="keyword">except</span> OneException <span class="keyword">as</span> alias:</span><br><span class="line">    deal <span class="keyword">with</span> it</span><br><span class="line"><span class="keyword">except</span> (TwoException,ThreeException):   <span class="comment"># 仅在多种异常的处理办法相同时才这么写</span></span><br><span class="line">    deal <span class="keyword">with</span> them</span><br><span class="line"><span class="keyword">except</span> BaseException:       <span class="comment"># 笼统地捕获各种异常</span></span><br><span class="line">    deal <span class="keyword">with</span> it</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    do something <span class="keyword">else</span>      <span class="comment"># 若try语句没有出一异常就执行</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    do things              <span class="comment"># 无论如何都会被运行的代码</span></span><br></pre></td></tr></table></figure><p>尽量避免在<code>finally</code>语句中使用<code>return</code>，且该语句中同样也可能抛出异常</p><p>主动抛出异常错误的关键词是<code>raise</code></p><p>主动抛出异常错误的关键词是<code>raise</code>，可以自定义抛出内容，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line"><span class="keyword">raise</span> -<span class="number">1</span></span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;n不能小于0&#x27;</span>)</span><br></pre></td></tr></table></figure><p>一般跳出循环都是用 <code>break</code>，但是只能跳出一层循环，可用异常处理的方式一次性跳出多层循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">if</span> i+j&gt;<span class="number">6</span>:</span><br><span class="line">                <span class="keyword">raise</span> -<span class="number">1</span></span><br><span class="line"><span class="keyword">except</span>:      <span class="comment"># 跳出两层</span></span><br><span class="line">    <span class="built_in">print</span>(i, j)</span><br></pre></td></tr></table></figure><p><code>sys.exc_info()</code> 返回程序最终引发异常的位置，但不容易定位真正出错的地方</p><h3 id="2-断言"><a href="#2-断言" class="headerlink" title="2. 断言"></a>2. 断言</h3><p>断言的语法：<code>assert expr [,reason]</code>。当 expr 为 True 时，什么都不做；为 False 时，抛出异常。</p><p>断言常常结合 <code>try...except...</code>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">assert</span> <span class="number">1</span>==<span class="number">2</span>, <span class="string">&#x27;NOT EQUAL!&#x27;</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> AssertionError <span class="keyword">as</span> reason:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125;：&#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(reason.__class__.__name__,reason))</span><br><span class="line">AssertionError：NOT EQUAL!</span><br></pre></td></tr></table></figure><h3 id="3-单元测试"><a href="#3-单元测试" class="headerlink" title="3. 单元测试"></a>3. 单元测试</h3><p>Python的<code>unittest</code> 模块提供单元测试的各种类和方法，常用 <code>TestCase</code>类。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/2022/01/28/python-3/py3.jpg&quot; class=&quot;&quot;&gt;

&lt;h2 id=&quot;第六章-面向对象程序设计&quot;&gt;&lt;a href=&quot;#第六章-面向对象程序设计&quot; class=&quot;headerlink&quot; title=&quot;第六章 面向对象程序设计&quot;&gt;&lt;/a&gt;第六章 面向对象程序设计&lt;/h2&gt;&lt;h3 id=&quot;1-定义与使用&quot;&gt;&lt;a href=&quot;#1-定义与使用&quot; class=&quot;headerlink&quot; title=&quot;1. 定义与使用&quot;&gt;&lt;/a&gt;1. 定义与使用&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Car&lt;/span&gt;:      &lt;span class=&quot;comment&quot;&gt;# 定义&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;info&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;self&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;#x27;Car.&amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;car = Car()     &lt;span class=&quot;comment&quot;&gt;# 实例化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;car.info()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记（二）</title>
    <link href="http://yoursite.com/2022/01/22/python-2/"/>
    <id>http://yoursite.com/2022/01/22/python-2/</id>
    <published>2022-01-22T13:03:29.000Z</published>
    <updated>2022-04-21T12:08:03.896Z</updated>
    
    <content type="html"><![CDATA[<img src="/2022/01/22/python-2/py2.jpg" class=""><h2 id="第三章-选择与循环"><a href="#第三章-选择与循环" class="headerlink" title="第三章 选择与循环"></a>第三章 选择与循环</h2><h3 id="1-条件表达式"><a href="#1-条件表达式" class="headerlink" title="1. 条件表达式"></a>1. 条件表达式</h3><p><strong>异或</strong>：符号 ^ ，就是说两个值不相同，则异或结果为真。反之，为假。 不同为1，相同为0。</p><p>Python中值为0、False、None或空对象均被视为False</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">1</span>&lt;<span class="number">2</span>&lt;<span class="number">3</span>)   <span class="comment"># 运算符可以连续使用</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">1</span>&lt;<span class="number">3</span>&gt;<span class="number">2</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>and和or支持惰性求值，前面的算完了后面的可能不算，可以设计表达式的前后关系提高效率</p><p>条件表达式中不能使用赋值&#x3D;</p><h3 id="2-选择结构"><a href="#2-选择结构" class="headerlink" title="2. 选择结构"></a>2. 选择结构</h3><p>Python支持如下语句用来代替Java的 ? : 运算符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">value_1 <span class="keyword">if</span> condition_sentence <span class="keyword">else</span> value_2   <span class="comment"># value可以是复杂语句</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math             <span class="comment"># 没导入random模块</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = math.sqrt(<span class="number">4</span>) <span class="keyword">if</span> <span class="number">3</span>&gt;<span class="number">2</span> <span class="keyword">else</span> random.randint(<span class="number">0</span>,<span class="number">3</span>)  <span class="comment"># 由于惰性求值，不会报错</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">2.0</span></span><br></pre></td></tr></table></figure><p><strong>多分支选择结构</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cond1:</span><br><span class="line">    value1</span><br><span class="line"><span class="keyword">elif</span> cond2:</span><br><span class="line">    value2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    value3</span><br></pre></td></tr></table></figure><p>选择结构嵌套时注意缩进</p><p><strong>日期模块</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> datetime</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = datetime.date.today()  <span class="comment"># 查看今天</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">datetime.date(<span class="number">2022</span>, <span class="number">1</span>, <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now</span><br><span class="line">datetime.datetime(<span class="number">2022</span>, <span class="number">1</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">13</span>, <span class="number">41</span>, <span class="number">774272</span>)</span><br></pre></td></tr></table></figure><h3 id="3-循环结构"><a href="#3-循环结构" class="headerlink" title="3. 循环结构"></a>3. 循环结构</h3><p>while和for语句均可带上一个else子句，表示在条件不满足时执行一次else中的语句，但如果训话不是自然结束而是由于break，则else中的语句不会执行。</p><p>break和continue也可以继续使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="string">&#x27;我&#x27;</span>,(<span class="string">&#x27;#&#x27;</span>,<span class="number">6</span>),<span class="string">&#x27;*&#x27;</span>,<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">enumerate</span>(a):    <span class="comment"># 遍历列表</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;第&#x27;</span>,i+<span class="number">1</span>,<span class="string">&#x27;个成员是：&#x27;</span>,v)   <span class="comment">#  print(&#x27;第&#123;0&#125;个成员是：&#123;1&#125;&#x27;.format(i+1,v))</span></span><br><span class="line">第 <span class="number">1</span> 个成员是： <span class="number">1</span></span><br><span class="line">第 <span class="number">2</span> 个成员是： 我</span><br><span class="line">第 <span class="number">3</span> 个成员是： (<span class="string">&#x27;#&#x27;</span>, <span class="number">6</span>)</span><br><span class="line">第 <span class="number">4</span> 个成员是： *</span><br><span class="line">第 <span class="number">5</span> 个成员是： <span class="number">0</span></span><br></pre></td></tr></table></figure><p>Python标准库itertools：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> itertools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">&#x27;An apple a day.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = itertools.cycle(x)    <span class="comment"># 循环元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="built_in">next</span>(y),end=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">A,n, ,a,p,p,l,e, ,a, ,d,a,y,.,A,n, ,a,p,</span><br><span class="line"></span><br><span class="line"><span class="comment"># 序列分组</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">group</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">if</span> num &gt; <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;大于10&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> num &lt; <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;小于5&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;在5和10之间&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    x = <span class="built_in">range</span>(<span class="number">20</span>)</span><br><span class="line">    y = itertools.groupby(x, group)</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> y:         <span class="comment"># y也是键值对形式</span></span><br><span class="line">        <span class="built_in">print</span>(k, <span class="string">&#x27;:&#x27;</span>, <span class="built_in">list</span>(v))</span><br><span class="line">        </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.permutations([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],<span class="number">3</span>)  <span class="comment"># [1,2,3,4]的全排列</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(x)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(x)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2 id="第四章-字符串与正则表达式"><a href="#第四章-字符串与正则表达式" class="headerlink" title="第四章 字符串与正则表达式"></a>第四章 字符串与正则表达式</h2><p>用以下两种方式指定Python程序的编码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="comment">#- * -coding:utf-8 - * -</span></span><br></pre></td></tr></table></figure><h3 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1. 字符串"></a>1. 字符串</h3><p>Python的字符串驻留机制似乎一直在改变之中，在《Python程序设计》（第二版）的书中描述的驻留特点在我的Python 3.8.2版本中已经过时，经过本机试验和网络资料，现在简单描述一下此版本的机制：</p><ul><li>字符串长度为0和1时，默认都采用了驻留机制。</li><li>字符串长度超过4096，默认都不驻留。</li><li>字符串长度大于1时，<ul><li>只包含大小写字母、数字、下划线时，默认驻留。</li><li>包含其余符号则不驻留。</li></ul></li><li>用乘法得到的字符串中，<ul><li>乘数为1时，<ul><li>仅包含大小写字母、数字、下划线时，默认驻留。</li><li>含其他字符串时，仅在总长&lt;&#x3D;1是驻留。</li></ul></li><li>乘数大于1时，与非乘法的字符串规则一致。</li></ul></li></ul><h4 id="1-1-格式化"><a href="#1-1-格式化" class="headerlink" title="1.1 格式化"></a>1.1 格式化</h4><p>推荐使用format() 方法进行格式化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)    <span class="comment"># 不设置指定位置，按默认顺序</span></span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)  <span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)  <span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">&#x27;world hello world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;the number &#123;0:,&#125; in hex is: &#123;0:#x&#125;; the number &#123;1:,&#125; in oct is &#123;1:#o&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">123</span>,<span class="number">555</span>))     <span class="comment"># 另外#b是二进制</span></span><br><span class="line">the number <span class="number">123</span> <span class="keyword">in</span> <span class="built_in">hex</span> <span class="keyword">is</span>: <span class="number">0x7b</span>; the number <span class="number">555</span> <span class="keyword">in</span> <span class="built_in">oct</span> <span class="keyword">is</span> <span class="number">0o1053</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;My name is &#123;name&#125;, age is &#123;age&#125;&#x27;</span>.<span class="built_in">format</span>(name = <span class="string">&#x27;Harry&#x27;</span>,age = <span class="number">10</span>))</span><br><span class="line">My name <span class="keyword">is</span> Harry, age <span class="keyword">is</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">23</span>,<span class="number">41</span>,<span class="number">20</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;A = &#123;0[0]&#125;,B = &#123;0[1]&#125;,C = &#123;0[2]&#125;&#x27;</span>.<span class="built_in">format</span>(nums))   <span class="comment">#取序列的值</span></span><br><span class="line">A = <span class="number">23</span>,B = <span class="number">41</span>,C = <span class="number">20</span></span><br></pre></td></tr></table></figure><h4 id="1-2-常用方法"><a href="#1-2-常用方法" class="headerlink" title="1.2 常用方法"></a>1.2 常用方法</h4><table><thead><tr><th>函   数</th><th>说   明</th></tr></thead><tbody><tr><td>str1.find(str2[,start[,end]])</td><td>在str1中找到str2，返回开始下标（找不到返回-1），end取不到</td></tr><tr><td>str1.rfind(str2)</td><td>从str1尾部向前找</td></tr><tr><td>str1.index(str2)</td><td>返回str2首次出现的位置，不存在则抛异常</td></tr><tr><td>str1.rindex(str2)</td><td>从str1尾部向前找</td></tr><tr><td>str1.count(str2)</td><td>str2在str1中出现的次数</td></tr><tr><td>split()</td><td>以指定字符从字符串左端开始分割，返回字符串列表；若不指定分隔符，则空格、换行、制表符都被认为是分隔符</td></tr><tr><td>rsplit()</td><td>以指定字符从字符串右端开始分割，返回字符串列表</td></tr><tr><td>partition(); rpartition();</td><td>以指定字符从字符串某一侧开始将其分割分成<strong>三部分</strong>：分隔符前的内容，分隔符，分隔符后的内容</td></tr><tr><td>str.join(list)</td><td>用str作为分隔符连接list内的各成员</td></tr><tr><td>lower(); upper()</td><td>字符串每个字母全转为小&#x2F;大写</td></tr><tr><td>capitalize()</td><td>第一个位置上若是字母，则变为大写，其余小写</td></tr><tr><td>title()</td><td>单词第一字母大写</td></tr><tr><td>swapcase()</td><td>大小写互换</td></tr><tr><td>str.replace(a,b)</td><td>替换str中所有的a为b</td></tr><tr><td>maketrans(); translate()</td><td>自定义字符串替换</td></tr><tr><td>strip(), rstrip(), lstrip()</td><td>删除两端，左端，右端的空白或连续的指定字符</td></tr><tr><td>eval()</td><td>尝试将str转成有意义的表达式并求之，注意异常</td></tr><tr><td>关键字 in</td><td>判断是否在字符串中，返回布尔值</td></tr><tr><td>startswith(), endswith()</td><td>字符串是否以其开头，还可限定起止范围，返回布尔值</td></tr><tr><td>isalnum()</td><td>是否是数字或者字母</td></tr><tr><td>isalpha()</td><td>是否是字母</td></tr><tr><td>isdigit()</td><td>是否是数字字符</td></tr><tr><td>isspace()</td><td>是否是空白字符（包括\n \t 等）</td></tr><tr><td>isupper()</td><td>是否全为大写字母</td></tr><tr><td>islower()</td><td>是否全为小写字母</td></tr><tr><td>center(); ljust(); rjust()</td><td>返回指定宽度的新字符串，居中、靠左对齐、靠右对齐</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;aabbcc&#x27;</span>.count(<span class="string">&#x27;c&#x27;</span>)   <span class="comment"># 计算c的个数</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;aabbcc&#x27;</span>.count(<span class="string">&#x27;&#x27;</span>)    <span class="comment"># 传空字符串</span></span><br><span class="line"><span class="number">7</span>                         <span class="comment"># 计算“缝隙”的个数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">&#x27;I have a dream.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.partition(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;have a dream.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># maketrans(); translate()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">&#x27;Hello world, I am python.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = x.maketrans(<span class="string">&#x27;ao&#x27;</span>,<span class="string">&#x27;xy&#x27;</span>)     <span class="comment"># 这里的替换大小写敏感</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.translate(s)</span><br><span class="line"><span class="string">&#x27;Helly wyrld, I xm pythyn.&#x27;</span>   <span class="comment"># 可以发现a对应x、o对应y</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">&#x27;asdfdaf&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.strip(<span class="string">&#x27;af&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;sdfd&#x27;</span>          <span class="comment"># 注意是把a和f全去掉了</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">&#x27;python&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.center(<span class="number">10</span>)</span><br><span class="line"><span class="string">&#x27;  python  &#x27;</span>     <span class="comment"># 居中</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.ljust(<span class="number">10</span>)</span><br><span class="line"><span class="string">&#x27;python    &#x27;</span>     <span class="comment"># 靠左</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.rjust(<span class="number">10</span>)</span><br><span class="line"><span class="string">&#x27;    python&#x27;</span>     <span class="comment"># 靠右</span></span><br></pre></td></tr></table></figure><p>字符串频率统计—— collections.Counter举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct = Counter(<span class="string">&#x27;aabcbacbcabcbacb&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct</span><br><span class="line">Counter(&#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">5</span>&#125;)   <span class="comment"># 注意也可以用dict()转成字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct[<span class="string">&#x27;a&#x27;</span>]   <span class="comment"># 取某元素的频次</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct.most_common(<span class="number">1</span>)   <span class="comment"># 统计出现次数最多的元素</span></span><br><span class="line">[(<span class="string">&#x27;b&#x27;</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct.most_common(<span class="number">2</span>)   <span class="comment"># 统计出现次数最多的两个元素</span></span><br><span class="line">[(<span class="string">&#x27;b&#x27;</span>, <span class="number">6</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="number">5</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct.most_common()    <span class="comment"># most_common()无参数则列出全部</span></span><br><span class="line">[(<span class="string">&#x27;b&#x27;</span>, <span class="number">6</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="number">5</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">5</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(ct.elements()) <span class="comment"># 按照元素出现次数生成列表</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(ct)   <span class="comment"># 排序，按序输出列表</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]  <span class="comment"># 注意重复元素只出现一次</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Counter对象之间可以相减（有什么用？见LeetCode 748. 最短补全词）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cx,cy = Counter(x),Counter(y)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cx</span><br><span class="line">Counter(&#123;<span class="number">1</span>: <span class="number">2</span>, <span class="number">4</span>: <span class="number">2</span>, <span class="number">5</span>: <span class="number">2</span>, <span class="number">2</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">1</span>, <span class="number">6</span>: <span class="number">1</span>, <span class="number">7</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cy</span><br><span class="line">Counter(&#123;<span class="number">2</span>: <span class="number">2</span>, <span class="number">1</span>: <span class="number">1</span>, <span class="number">6</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cx-cy</span><br><span class="line">Counter(&#123;<span class="number">4</span>: <span class="number">2</span>, <span class="number">5</span>: <span class="number">2</span>, <span class="number">1</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">1</span>, <span class="number">7</span>: <span class="number">1</span>&#125;)  <span class="comment"># 各个词频相减</span></span><br><span class="line"><span class="comment"># 注意如果词频相减有负数，不放入最终结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m,n = <span class="string">&#x27;abbc&#x27;</span>,<span class="string">&#x27;aabcd&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cm,cn = Counter(m),Counter(n)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cm,cn</span><br><span class="line">(Counter(&#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">1</span>&#125;), Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">1</span>&#125;))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cm-cn</span><br><span class="line">Counter(&#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">1</span>&#125;)   <span class="comment"># 只有&#x27;b&#x27;的频数相减为正，故结果里只有&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="1-3-字符串常量"><a href="#1-3-字符串常量" class="headerlink" title="1.3 字符串常量"></a>1.3 字符串常量</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line">string.digits</span><br><span class="line">string.punctuation   <span class="comment"># 标点符号</span></span><br><span class="line">string.ascii_letters  <span class="comment"># 大小写字母</span></span><br><span class="line">string.printable    <span class="comment"># 可打印字符</span></span><br><span class="line">string.ascii_lowercase</span><br><span class="line">sting.ascii_uppercase</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成建议密码</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_password</span>(<span class="params">size</span>):</span><br><span class="line">    str_pool = string.digits + string.ascii_letters + string.punctuation</span><br><span class="line">    pwd1 = <span class="string">&#x27;&#x27;</span>.join(random.choice(str_pool) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size))</span><br><span class="line">    pwd2 = <span class="string">&#x27;&#x27;</span>.join(random.sample(str_pool, size))</span><br></pre></td></tr></table></figure><p>其中，<strong>random模块</strong>常用函数</p><table><thead><tr><th>函   数</th><th>说   明</th></tr></thead><tbody><tr><td>choice(seq)</td><td>从序列中任选一个</td></tr><tr><td>sample(seq,size)</td><td>从序列中不重复地选择size个</td></tr><tr><td>getrandbits(x)</td><td>生成二进制最大是x位的随机整数（如x&#x3D;3时会返回000之类的）</td></tr><tr><td>randrange(); randint()</td><td>返回随机整数，前者左闭右开，后者左闭右闭</td></tr><tr><td>shuffle(seq)</td><td>原地打乱</td></tr></tbody></table><h4 id="1-4-可变字符串"><a href="#1-4-可变字符串" class="headerlink" title="1.4 可变字符串"></a>1.4 可变字符串</h4><p>要用 <code>io.StringIO</code> 或 <code>array</code> 模块</p><h3 id="2-正则表达式"><a href="#2-正则表达式" class="headerlink" title="2. 正则表达式"></a>2. 正则表达式</h3><h4 id="2-1-语法"><a href="#2-1-语法" class="headerlink" title="2.1 语法"></a>2.1 语法</h4><p><strong>元字符</strong> </p><table><thead><tr><th>表  达  式</th><th>含   义</th></tr></thead><tbody><tr><td>expr*</td><td>表达式expr出现0次或更多次</td></tr><tr><td>expr+</td><td>表达式expr出现1次或多次</td></tr><tr><td>expr?</td><td>表达式expr出现0或1次</td></tr><tr><td>expr{n}</td><td>表达式expr正好出现n次</td></tr><tr><td>expr{m,n}</td><td>表达式expr最少出现m次，最多n次（expr{0,1}⟺expr?）</td></tr><tr><td>expr{m,}</td><td>表达式expr最少出现m次</td></tr><tr><td>expr{,n}</td><td>表达式expr最多出现n次</td></tr><tr><td>\d</td><td>任意一个数字（0~9）</td></tr><tr><td>\D</td><td>任意一个非数字</td></tr><tr><td>\s</td><td>任意一个空白字符（如换页符、制表符）</td></tr><tr><td>\S</td><td>任意一个非空白字符</td></tr><tr><td>\w</td><td>任意一个数字、字母或下划线</td></tr><tr><td>\W</td><td>与\w相反</td></tr><tr><td>\b</td><td>匹配单词头或尾</td></tr><tr><td>\B</td><td>匹配单词中间</td></tr><tr><td>()</td><td>将括号内容作为一个整体来对待</td></tr><tr><td>[]</td><td>匹配位于括号内的任意一个字符</td></tr><tr><td>-</td><td>用于[]内，表示范围</td></tr><tr><td>.</td><td>匹配除换行符外的任意单个字符</td></tr><tr><td>^</td><td>表示行的开头，匹配以^之后字符开头的字符串</td></tr><tr><td>$</td><td>表示行的结束，匹配以$之前字符结尾的字符串</td></tr><tr><td>[^expr]</td><td>匹配表达式expr所表示的以外的字符</td></tr><tr><td>expr_1|expr_2</td><td>匹配表达式expr_1或expr_2</td></tr></tbody></table><p><code>[\u4e00-\u9fa5]</code>：匹配是否为汉字</p><h4 id="2-2-re-模块"><a href="#2-2-re-模块" class="headerlink" title="2.2 re 模块"></a>2.2 re 模块</h4><p><strong>主要方法</strong></p><table><thead><tr><th>方    法</th><th>说   明</th></tr></thead><tbody><tr><td>compile(pattern[, flags])</td><td>创建模式对象</td></tr><tr><td>search(pattern, string[, flags])</td><td>在整个字符串中寻找模式，返回match对象或None</td></tr><tr><td>match(pattern, string[, flags])</td><td>从字符串的开始处匹配模式，返回match对象或None</td></tr><tr><td>findall(pattern, string[, flags])</td><td>列出字符串中模式的所有匹配项，返回一个列表</td></tr><tr><td>split(pattern, string[, maxsplit&#x3D;0])</td><td>根据模式匹配分割字符串</td></tr><tr><td>sub(pat, repl[, count&#x3D;0])</td><td>将字符串中所有pat匹配项用repl替换</td></tr><tr><td>escape(string)</td><td>将字符串中所有特殊正则表达式字符转义</td></tr></tbody></table><p>其中 <code>mathc()</code>和<code>search()</code>都返回一个match对象，该对象常用的方法有<code>group()、groups()、groupdict()、start()、end()、span()</code>等。</p><h2 id="第五章-函数设计与使用"><a href="#第五章-函数设计与使用" class="headerlink" title="第五章 函数设计与使用"></a>第五章 函数设计与使用</h2><h3 id="1-形参与实参"><a href="#1-形参与实参" class="headerlink" title="1. 形参与实参"></a>1. 形参与实参</h3><p>在函数内部修改形参不会改变实参的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    a += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    add(a)</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span>   <span class="comment"># a的值并未被改变</span></span><br></pre></td></tr></table></figure><h3 id="2-参数类型"><a href="#2-参数类型" class="headerlink" title="2. 参数类型"></a>2. 参数类型</h3><h4 id="2-1-默认值参数"><a href="#2-1-默认值参数" class="headerlink" title="2.1 默认值参数"></a>2.1 默认值参数</h4><p>定义函数时为形参设置默认值，语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func_name</span>(<span class="params">..., 形参名=默认值</span>):</span><br><span class="line">    函数体</span><br><span class="line">func_name.__defaults__    <span class="comment"># 查看函数所有默认值</span></span><br></pre></td></tr></table></figure><p>定义带有默认值参数的函数时，默认值参数必须出现在函数形参列表的<strong>最右端</strong>，即默认值参数的右边不能再出现非默认值参数。</p><p><strong>注意</strong> 默认值参数只在第一次调用时进行解释，可能会有意外的错误，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">dd</span>(<span class="params">new, old_list=[]</span>):</span><br><span class="line"><span class="meta">... </span>    old_list.append(new)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> old_list</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(dd(<span class="string">&#x27;5&#x27;</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;5&#x27;</span>]     <span class="comment"># 正常调用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(dd(<span class="string">&#x27;a&#x27;</span>)) <span class="comment">#第一次调用</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(dd(<span class="string">&#x27;b&#x27;</span>))  <span class="comment">#第二次调用</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]      <span class="comment"># old_list 默认继承了上一次的结果</span></span><br></pre></td></tr></table></figure><h4 id="2-2-关键参数"><a href="#2-2-关键参数" class="headerlink" title="2.2 关键参数"></a>2.2 关键参数</h4><p>可以按照参数名字传值，而不用牢记形参定义时的顺序，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">pp</span>(<span class="params">a, b, c</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(a, b, c)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pp(c = <span class="number">3</span>, a = <span class="number">1</span>, b = <span class="number">2</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="2-3-可变长度参数"><a href="#2-3-可变长度参数" class="headerlink" title="2.3 可变长度参数"></a>2.3 可变长度参数</h4><p>有两种形式：</p><ol><li>*parameter，接收任意多个参数并放入元组中，如：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">demo</span>(<span class="params">*p</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(p)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo(<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;haha&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;haha&#x27;</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>**parameter，类似关键参数，调用函数时显示赋值给形参：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo</span>(<span class="params">**p</span>):</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> p.items():</span><br><span class="line">        <span class="built_in">print</span>(item)     <span class="comment"># item是元组类</span></span><br><span class="line">&gt;&gt; demo(x=<span class="number">1</span>, y=<span class="number">2</span>, z=<span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;x&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">&#x27;y&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;string&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="2-4-参数传递时序列解包"><a href="#2-4-参数传递时序列解包" class="headerlink" title="2.4 参数传递时序列解包"></a>2.4 参数传递时序列解包</h4><p>可以使用列表、元组、集合、字典等序列为含多个变量的函数传递参数，在实参前加一个*进行解包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">plus</span>(<span class="params">a, b, c</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(a+b+c)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plus(*seq)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup = (<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plus(*tup)</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>= &#123;<span class="number">1</span>:<span class="string">&#x27;a&#x27;</span>,<span class="number">2</span>:<span class="string">&#x27;b&#x27;</span>,<span class="number">3</span>:<span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plus(*<span class="built_in">dict</span>)      <span class="comment"># 默认操作key</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>= &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plus(*<span class="built_in">dict</span>.values())</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p>务必保证序列元素个数与参数个数一致。</p><h3 id="3-变量作用域"><a href="#3-变量作用域" class="headerlink" title="3. 变量作用域"></a>3. 变量作用域</h3><p>变量已在函数外定义，在函数内引用可直接用，而要修改该变量的值需要在函数内用<code>global</code>声明这个变量为全局变量，明确使用同名全局变量。</p><p>在函数内部直接使用<code>global</code>关键字将一个变量声明为全局变量，即使在函数外没有定义该全局变量，在调用这个函数后将自动增加新的全局变量。</p><p>如果局部变量与全局变量名字相同，局部变量会将全局变量隐藏，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">dd</span>():</span><br><span class="line"><span class="meta">... </span>    x = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd()</span><br><span class="line"><span class="number">2</span>    </span><br></pre></td></tr></table></figure><h3 id="4-lambda-表达式"><a href="#4-lambda-表达式" class="headerlink" title="4. lambda 表达式"></a>4. lambda 表达式</h3><p>用于声明没有函数名字而临时定义的匿名函数，只可以包含一个表达式，不允许包含复杂语句，但可以调用其他的函数，支持默认值参数和关键参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="keyword">lambda</span> x, y, z: x+ y+ z</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = <span class="keyword">lambda</span> x, y=<span class="number">2</span>, z=<span class="number">3</span>: x+y+z   <span class="comment"># 默认值参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(g(<span class="number">1</span>))</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(g(<span class="number">2</span>, z=<span class="number">4</span>, y=<span class="number">5</span>))   <span class="comment"># 调用时使用关键参数</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [(<span class="keyword">lambda</span> x: x**<span class="number">2</span>), (<span class="keyword">lambda</span> x: x**<span class="number">3</span>), (<span class="keyword">lambda</span> x: x**<span class="number">4</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(L[<span class="number">0</span>](<span class="number">3</span>),L[<span class="number">1</span>](<span class="number">2</span>),L[<span class="number">2</span>](<span class="number">2</span>))    <span class="comment"># 列表形式</span></span><br><span class="line"><span class="number">9</span> <span class="number">8</span> <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = <span class="built_in">map</span>((<span class="keyword">lambda</span> x:x*<span class="number">2</span>),x)  <span class="comment"># 匿名函数，操作列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(res)</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>使用<code>lambda</code>表达式时，要注意变量作用域的问题。外部定义的变量不是局部变量，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    r.append(<span class="keyword">lambda</span>: x**<span class="number">2</span>)     <span class="comment"># 错误写法，x不是局部变量</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r[<span class="number">0</span>]()</span><br><span class="line"><span class="number">81</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r[<span class="number">3</span>]()</span><br><span class="line"><span class="number">81</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    r.append(<span class="keyword">lambda</span> n=x: n**<span class="number">2</span>)  <span class="comment"># 正确写法</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r[<span class="number">0</span>]()</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r[<span class="number">1</span>]()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r[<span class="number">2</span>]()</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="5-高级话题"><a href="#5-高级话题" class="headerlink" title="5. 高级话题"></a>5. 高级话题</h3><ul><li>reduce()</li></ul><p>接收两个参数，以累积的方式从左到右依次作用到一个序列或迭代器对象的所有元素上，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x,y:x+y,seq)</span><br><span class="line"><span class="number">28</span></span><br></pre></td></tr></table></figure><ul><li>filter()</li></ul><p>将一个单参数函数<code>fun()</code>作用到另一个序列上，返回该序列中使得<code>fun()</code>的返回值为True的那些元素组成的序列，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq = [<span class="string">&#x27;12-1&#x27;</span>,<span class="string">&#x27;aasd&#x27;</span>,<span class="string">&#x27;**&#x27;</span>,<span class="string">&#x27;3t&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x.isalnum()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">filter</span>(func,seq)</span><br><span class="line">&lt;<span class="built_in">filter</span> <span class="built_in">object</span> at <span class="number">0x000001ED89839370</span>&gt;   <span class="comment"># 注意返回filter对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">filter</span>(func,seq))</span><br><span class="line">[<span class="string">&#x27;aasd&#x27;</span>, <span class="string">&#x27;3t&#x27;</span>]</span><br></pre></td></tr></table></figure><ul><li>yield()</li></ul><p>书中讲得一知半解，参考这篇博文：<a href="https://blog.csdn.net/mieleizhi0522/article/details/82142856">《python中yield的用法详解——最简单，最清晰的解释》</a></p><p>总结一下：<code>yield</code>首先是起到<code>return</code>的作用，即返回值；带<code>yield</code>的函数是一个生成器，而不是一个函数，这个生成器有一个<code>__next__()</code> 函数，相当于“下一步”生成哪个数，这一次的<code>__next__()</code>开始的地方是接着上一次的<code>__next__()</code>停止的地方执行的。再看下面的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line"><span class="meta">... </span>    a,b=<span class="number">1</span>,<span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">yield</span> a    <span class="comment"># 先返回a的值</span></span><br><span class="line"><span class="meta">... </span>            a,b=b,a+b</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = f()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(a.__next__(),end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span></span><br></pre></td></tr></table></figure><ul><li><p>使用<code>dis</code>模块查看函数的字节码指令</p></li><li><p>嵌套定义与可调用对象</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">linear</span>(<span class="params">a,b</span>);</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">result</span>(<span class="params">x</span>):     <span class="comment"># 函数定义嵌套</span></span><br><span class="line">        <span class="keyword">return</span> a *x +b</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">linear</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a, b</span>):    <span class="comment"># 新建对象时候调用</span></span><br><span class="line">        self.a, self.b = a, b</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, x</span>):       <span class="comment"># 调用已有对象时用。任何包含__call__()的类的对象都是可调用的</span></span><br><span class="line">        <span class="keyword">return</span> self.a *x +self.b</span><br><span class="line">    </span><br><span class="line">t = linear(<span class="number">0.3</span>, <span class="number">2</span>)      <span class="comment"># 定义一个可调用对象</span></span><br><span class="line">t(<span class="number">5</span>)                    <span class="comment"># 使用</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/2022/01/22/python-2/py2.jpg&quot; class=&quot;&quot;&gt;

&lt;h2 id=&quot;第三章-选择与循环&quot;&gt;&lt;a href=&quot;#第三章-选择与循环&quot; class=&quot;headerlink&quot; title=&quot;第三章 选择与循环&quot;&gt;&lt;/a&gt;第三章 选择与循环&lt;/h2&gt;&lt;h3 id=&quot;1-条件表达式&quot;&gt;&lt;a href=&quot;#1-条件表达式&quot; class=&quot;headerlink&quot; title=&quot;1. 条件表达式&quot;&gt;&lt;/a&gt;1. 条件表达式&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;异或&lt;/strong&gt;：符号 ^ ，就是说两个值不相同，则异或结果为真。反之，为假。 不同为1，相同为0。&lt;/p&gt;
&lt;p&gt;Python中值为0、False、None或空对象均被视为False&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>由一个hexo部署问题说起</title>
    <link href="http://yoursite.com/2022/01/18/update-hexo/"/>
    <id>http://yoursite.com/2022/01/18/update-hexo/</id>
    <published>2022-01-18T14:17:03.000Z</published>
    <updated>2022-04-21T12:08:03.902Z</updated>
    
    <content type="html"><![CDATA[<img src="/2022/01/18/update-hexo/site.jpg" class="" title="Image from https:&#x2F;&#x2F;ist.mit.edu&#x2F;"><p>最近有时间，终于重启了自己的在 GitHub Pages 上的博客，用 hexo 建立网站确实省心省力，然而我也遇到了一些问题，在此记录一下 hexo 部署时的小波折。</p><span id="more"></span><p>和往常一样，我依然使用 <code>hexo clean</code> 、<code>hexo g</code>、<code>hexo d</code> 三个命令部署更新网站，然而在执行第三个命令时收到了这样一个错误提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git@github.com: Permission denied (publickey).</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>于是，非常自然地想到是不是 SSH 连接的问题，经过网上一番搜索，我首先在 C 盘 .ssh 文件夹目录下新建了一个名为 config 的文件，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User address@mail.com</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure><p>重新尝试部署，依然出错，错误提示一样。最好还是看官方文档，于是，我在 GitHub Docs上找到了<a href="https://docs.github.com/en/authentication/troubleshooting-ssh/error-permission-denied-publickey">这个</a>页面，按照它里面的操作步骤一步步排查问题。可以发现，在执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -vT git@github.com</span><br></pre></td></tr></table></figure><p>命令时，我的机器是可以连上 github.com 的，但其中，我本机的详情信息略有不同，最关键的两行信息如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">debug1: identity file /Users/you/.ssh/id_dsa <span class="built_in">type</span> 0</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">debug1: identity file /Users/you/.ssh/id_dsa-cert <span class="built_in">type</span> -1</span></span><br></pre></td></tr></table></figure><p>结合官方给出的文档，我发现是由于缺失了 <code>id_dsa-cert</code> 文件所致，但去 .ssh 文件夹下，却没有发现这个文件。问题是，这个 SSH key 是我在前几天生成的新 key，为什么现在提示我会缺少这么一个文件呢？于是我大胆假设：<strong>hexo是不是版本太老，所需要的文件如今的系统是不会生成的</strong>。用 <code>hexo -v</code> 命令一看，居然是 1.x 版本！当初我建立博客还是在2018年，这么久过去了，我从未主动更新过 hexo，现在最新版本已到达 6.0.0，时代变了。</p><p>hexo 的运行依赖 npm，我想到自己的 Node 也不是新版本，于是去 Node.js 官网下载并覆盖安装最新的稳定版本，然后使用 <code>node -v</code> 查看版本更新是否成功。</p><p>接下来若是尝试运行 hexo 的任何指令，都会提示我无法找到该命令。不急不急，使用以下命令全局更新 hexo：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-cli -g</span><br></pre></td></tr></table></figure><p>安装 npm-check：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i npm-check -g</span><br></pre></td></tr></table></figure><p>然后再运行 <code>npm-check</code> 指令，这里就展示了需要升级的各种插件，可以发现 hexo 赫然在列。</p><p>再执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install -g npm-upgrade   // 安装npm-upgrade</span><br><span class="line">npm-upgrade        // 更新package.json，这里一路yes即可</span><br><span class="line">npm update -g      //更新全局插件</span><br><span class="line">npm update --save  //更新系统插件</span><br></pre></td></tr></table></figure><p>其中几乎每一步都花费了几分钟时间，的确，我系统中各种插件都长时间没有更新了。在执行第三条命令的时候，还出现了 “npm ERR! The operation was rejected by your operating system.” 的错误，在 Windows 10系统上，搜索并进入设置的“PowerShell开发者选项”，勾选并“应用”如下图所示的选项即可成功运行该命令。</p><img src="/2022/01/18/update-hexo/powershell.jpg" class=""><p>终于更新完，来检验一下成果，运行 <code>hexo -v</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo: 6.0.0</span><br><span class="line">hexo-cli: 4.3.0</span><br><span class="line">os: win32 10.0.19044</span><br><span class="line">node: 16.13.2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>更新成功！最终新的文章也成功部署到了网站上。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://www.ouyanting.com/archives/2021/01/b04198fc.html">hexo升级</a></li><li><a href="https://cloud.tencent.com/developer/article/1758175">博客更新：Hexo更新到5.2.0版本血泪踩坑史</a></li><li><a href="https://docs.github.com/en/authentication/troubleshooting-ssh/error-permission-denied-publickey">GitHub Docs - Error: Permission denied (publickey)</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/2022/01/18/update-hexo/site.jpg&quot; class=&quot;&quot; title=&quot;Image from https:&amp;#x2F;&amp;#x2F;ist.mit.edu&amp;#x2F;&quot;&gt;

&lt;p&gt;最近有时间，终于重启了自己的在 GitHub Pages 上的博客，用 hexo 建立网站确实省心省力，然而我也遇到了一些问题，在此记录一下 hexo 部署时的小波折。&lt;/p&gt;</summary>
    
    
    
    
    <category term="经验总结" scheme="http://yoursite.com/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记（一）</title>
    <link href="http://yoursite.com/2022/01/17/python-1/"/>
    <id>http://yoursite.com/2022/01/17/python-1/</id>
    <published>2022-01-17T09:36:24.000Z</published>
    <updated>2022-04-21T12:08:03.896Z</updated>
    
    <content type="html"><![CDATA[<img src="/2022/01/17/python-1/py1.jpg" class=""><h2 id="第一章-基础知识"><a href="#第一章-基础知识" class="headerlink" title="第一章 基础知识"></a>第一章 基础知识</h2><h3 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h3><p>IDEA中安装Python插件，即可满足学习需要</p><p>IDE中要运行一个程序，必须写好这么一行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>: </span><br></pre></td></tr></table></figure><p>意思是：当模块被直接运行时，以下代码块将被运行；当模块是被导入时，代码块不被运行。</p><span id="more"></span><p><strong>输出</strong>：在 print() 内输入多个字符串，再用“,”连接，可以合在一起输出一个完整的字符串，遇到一个“,”就输出一个空格。<br>输出100+200的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;100 + 200 =&#x27;</span>, <span class="number">100</span> + <span class="number">200</span>)</span><br><span class="line"><span class="number">100</span> + <span class="number">200</span> = <span class="number">300</span></span><br></pre></td></tr></table></figure><p>要让print()函数输出后不换行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><p><strong>输入</strong>:用 input() 让用户输入字符串，再存储到一个变量里。input() 可以让你显示一个字符串来提示用户，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&#x27;please enter your name: &#x27;</span>)</span><br></pre></td></tr></table></figure><p>input()返回的都是str类型</p><h4 id="1-1-变量"><a href="#1-1-变量" class="headerlink" title="1.1 变量"></a>1.1 变量</h4><p>不需要声明类型，直接赋值就创建了一个变量</p><p>Python 动态类型语言——变量类型可以变化，在新声明之前，变量一直保持原来的类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(var)  <span class="comment"># 查看变量类型</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="number">54</span>,<span class="built_in">str</span>)  <span class="comment"># 查看是否为指定类型</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x=<span class="number">3</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(x**<span class="number">2</span>)      <span class="comment"># 乘方</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">1</span>]=<span class="number">0</span>        <span class="comment"># 修改list（str和tuple不可修改）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(x)</span><br><span class="line">[<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(var)     <span class="comment"># 返回var的内存地址</span></span><br></pre></td></tr></table></figure><p>相同的值在内存中只保留一份，多个变量可指向同一个地址</p><ul><li>变量名必须以字母或下划线开头</li><li>名字中不能有空格和标点符号</li><li>关键字也不行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> keyword</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>keyword.kwlist   <span class="comment"># 查看所有关键字</span></span><br><span class="line">[<span class="string">&#x27;False&#x27;</span>, <span class="string">&#x27;None&#x27;</span>, <span class="string">&#x27;True&#x27;</span>, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;as&#x27;</span>, <span class="string">&#x27;assert&#x27;</span>, <span class="string">&#x27;async&#x27;</span>, <span class="string">&#x27;await&#x27;</span>, <span class="string">&#x27;break&#x27;</span>, <span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;continue&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;del&#x27;</span>, <span class="string">&#x27;elif&#x27;</span>, <span class="string">&#x27;else&#x27;</span>, <span class="string">&#x27;except&#x27;</span>, <span class="string">&#x27;finally&#x27;</span>, <span class="string">&#x27;for&#x27;</span>, <span class="string">&#x27;from&#x27;</span>, <span class="string">&#x27;global&#x27;</span>, <span class="string">&#x27;if&#x27;</span>, <span class="string">&#x27;import&#x27;</span>, <span class="string">&#x27;in&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;lambda&#x27;</span>, <span class="string">&#x27;nonlocal&#x27;</span>, <span class="string">&#x27;not&#x27;</span>, <span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;pass&#x27;</span>, <span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;return&#x27;</span>, <span class="string">&#x27;try&#x27;</span>, <span class="string">&#x27;while&#x27;</span>, <span class="string">&#x27;with&#x27;</span>, <span class="string">&#x27;yield&#x27;</span>]</span><br></pre></td></tr></table></figure><ul><li>变量名区分大小写</li></ul><h4 id="1-2-数字"><a href="#1-2-数字" class="headerlink" title="1.2 数字"></a>1.2 数字</h4><p>不可变</p><p>标准库 import math</p><ul><li>十六进制必须以0x开头</li><li>八进制必须以0o开头</li><li>二进制必须以0b开头</li></ul><p>虚数用j表示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x=<span class="number">3</span>+<span class="number">5j</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.real  <span class="comment"># 查看实部</span></span><br><span class="line"><span class="number">3.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.imag  <span class="comment"># 查看虚部</span></span><br><span class="line"><span class="number">5.0</span></span><br></pre></td></tr></table></figure><p>Python中的布尔值本质就是0和1，因此可以和数字进行运算。bool值只有True和False两种。</p><h4 id="1-3-字符串"><a href="#1-3-字符串" class="headerlink" title="1.3 字符串"></a>1.3 字符串</h4><p>不可变，可用一对单引号、双引号、三引号嵌套表示，支持用 + 合成</p><p>字符串引号前加 r 或 R 取消转义符</p><table><thead><tr><th>函    数</th><th>说    明</th></tr></thead><tbody><tr><td>ord(str)</td><td>获取字符编码的整数表示</td></tr><tr><td>chr(str)</td><td>把编码转成字符</td></tr><tr><td>len(str)</td><td>计算 str 中包含的字符数</td></tr><tr><td>str.join(list)</td><td>用str来连接list中的各个成员</td></tr><tr><td>str.split([s])</td><td>s默认为空格，但不可以是’’，返回字符串列表list</td></tr></tbody></table><p>join()函数用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>]   <span class="comment"># 序列中的元素也要是str类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;**&quot;</span>.join(a)   <span class="comment"># 用**来链接序列的各个成员</span></span><br><span class="line"><span class="string">&#x27;1**2**3**4&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="1-4-运算符"><a href="#1-4-运算符" class="headerlink" title="1.4 运算符"></a>1.4 运算符</h4><table><thead><tr><th align="center">符号示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">x&#x2F;&#x2F;y</td><td align="center">求整数商</td></tr><tr><td align="center">x**y</td><td align="center">幂</td></tr><tr><td align="center">x or y</td><td align="center">逻辑或（只有x为假才计算y）</td></tr><tr><td align="center">x and y</td><td align="center">逻辑与（只有x为真才计算y）</td></tr><tr><td align="center">not x</td><td align="center">逻辑非</td></tr><tr><td align="center">x in y; x not in y</td><td align="center">判断是否是成员</td></tr><tr><td align="center">x is y; x is not y</td><td align="center">测试内存地址（对象同一性）</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;a&#x27;</span>*<span class="number">6</span>        <span class="comment"># 字符重复</span></span><br><span class="line"><span class="string">&#x27;aaaaaa&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]*<span class="number">3</span>    <span class="comment"># list重复</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)*<span class="number">2</span>    <span class="comment"># 元组重复</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span>*[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]    <span class="comment"># 交换律</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x,y = y,x   <span class="comment"># 交换</span></span><br></pre></td></tr></table></figure><h4 id="1-5-常用内置函数"><a href="#1-5-常用内置函数" class="headerlink" title="1.5 常用内置函数"></a>1.5 常用内置函数</h4><p>用 help(funname) 查看函数用法</p><table><thead><tr><th align="center">函    数</th><th align="center">功   能</th></tr></thead><tbody><tr><td align="center">abs(x)</td><td align="center">绝对值</td></tr><tr><td align="center">all(iterable)</td><td align="center">若可迭代对象中所有bool(x)均为True，则函数返回True</td></tr><tr><td align="center">any(iterable)</td><td align="center">若可迭代对象中存在bool(x)为True，则函数返回True</td></tr><tr><td align="center">bin(x)</td><td align="center">将数字转为二进制串str</td></tr><tr><td align="center">dir(x)</td><td align="center">返回成员列表</td></tr><tr><td align="center">list(x);set(x);tuple(x);dict(x)</td><td align="center">把对象转成列表、集合、元组或字典</td></tr><tr><td align="center">reverse(list or tuple)</td><td align="center">逆序</td></tr><tr><td align="center">sorted(x)</td><td align="center">排序</td></tr><tr><td align="center">int(x);float(x)</td><td align="center">转类型</td></tr></tbody></table><p>编码时优先考虑内置函数</p><p><strong>del</strong> 命令删除变量的值，或序列的成员，或整个序列，但不可删除不可变序列的指定元素。</p><h4 id="1-6-模块导入和使用"><a href="#1-6-模块导入和使用" class="headerlink" title="1.6 模块导入和使用"></a>1.6 模块导入和使用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math <span class="keyword">as</span> m  <span class="comment"># 设置别名</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> sin    <span class="comment"># 导入明确对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sin(<span class="number">1</span>)                  <span class="comment"># 无序加模块名作为前缀</span></span><br><span class="line"><span class="number">0.8414709848078965</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> random <span class="keyword">import</span> *   <span class="comment"># 方便但不推荐</span></span><br></pre></td></tr></table></figure><p>大项目中导入模块的顺序：导入标准库、导入第三方库、导入自己开发的本地库</p><h3 id="2-规范"><a href="#2-规范" class="headerlink" title="2. 规范"></a>2. 规范</h3><ul><li>变量名尽量小写, 如有多个单词，用下划线隔开；类内部变量命名，用单下划线(_)开头（该变量可被继承访问）；类内私有变量命名，用双下划线(__)开头（该变量不可被继承访问） school_name &#x3D; ‘ujs’</li><li>常量采用全大写，如有多个单词，使用下划线隔开   MAX_CONNECTION &#x3D; 1000</li><li>函数名一律小写，如有多个单词，用下划线隔开    def run_with_env():</li><li>类内部函数命名，用单下划线(_)开头（该函数可被继承访问）</li><li>类内私有函数命名，用双下划线(__)开头（该函数不可被继承访问）</li><li>类名使用驼峰(CamelCase)命名风格，首字母大写，私有类可用一个下划线开头  class AnimalFarm(Farm):</li><li>函数之间空两行，类成员函数之间空一行</li><li>每个import尽量只导入一个模块</li></ul><h3 id="3-包的使用"><a href="#3-包的使用" class="headerlink" title="3. 包的使用"></a>3. 包的使用</h3><p>每个目录中都必须包含一个 __init__.py 文件（可以是空），以表示该目录是一个包</p><p>按照包的结构用 ”.“ 分隔import，类似于Java</p><h2 id="第二章-序列"><a href="#第二章-序列" class="headerlink" title="第二章 序列"></a>第二章 序列</h2><p>无序序列：字典（3.6开始字典也是有序的了）、集合</p><p>列表、元组、字符串可双向索引，亦可用负数索引，最后一个元素是-1，倒数第二个是-2……</p><h3 id="1-列表"><a href="#1-列表" class="headerlink" title="1. 列表"></a>1. 列表</h3><p>一个列表中的元素类型可以不同</p><table><thead><tr><th align="left">方   法</th><th align="left">说   明</th></tr></thead><tbody><tr><td align="left">list.append(x)</td><td align="left">末尾追加</td></tr><tr><td align="left">list.extend(L)</td><td align="left">末尾加上L的所有元素</td></tr><tr><td align="left">list.insert(index,x)</td><td align="left">指定位置添加（index前面）</td></tr><tr><td align="left">list.remove(x)</td><td align="left">删除首次出现的x，若不存在则抛异常</td></tr><tr><td align="left">list.pop([index])</td><td align="left"><strong>删除并返回</strong>指定位置的元素，默认是最后一个元素</td></tr><tr><td align="left">list.clear()</td><td align="left">清空列表成员，但保留列表对象</td></tr><tr><td align="left">list.index(x)</td><td align="left">返回首次出现x的位置，如果没有就抛异常</td></tr><tr><td align="left">list.count(x)</td><td align="left">统计x出现的次数</td></tr><tr><td align="left">list.reverse()</td><td align="left">原地翻转</td></tr><tr><td align="left">list.sort()</td><td align="left">排序（Unicode），会改变原有list</td></tr><tr><td align="left">list.copy()</td><td align="left">浅拷贝</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>))   <span class="comment"># range三个参数注意区别，第二个参数取不到</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># append()、extend()、+= 的辨析</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.append(<span class="number">4</span>)  <span class="comment"># 末尾添加一个元素4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.append([<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])  <span class="comment"># 末尾添加一个元素[5,6,7]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.extend([<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>])  <span class="comment"># 末尾扩展加上三个元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>], <span class="number">6</span>, <span class="number">0</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.extend(&#123;<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>&#125;)  <span class="comment"># extend()可接收iterable的参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>], <span class="number">6</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr+=(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>)   <span class="comment"># extend() 与 += 效果完全一样，推荐用+=</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>], <span class="number">6</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：extend() 与 +&#x3D; 效果完全一样，而extend()涉及函数调用，效率差一点，因此推荐用+&#x3D;</p><p>列表中修改序列某成员，不改变改列表对象本身的地址</p><p>用乘法扩展（重复）原序列，该操作实际创建了一个新序列。且这些重复是已有对象的引用，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]*<span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[[<span class="number">10</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">10</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">10</span>, <span class="number">2</span>, <span class="number">3</span>]]     <span class="comment"># 重复对象也发生了改变</span></span><br></pre></td></tr></table></figure><p>查看某个元素是否在序列中，可用 in &#x2F; not in 关键字</p><p><strong>切片</strong> 用两个冒号分隔的三个数字完成，数字分别表示开始位置（默认0）、结束（但不包含）位置（默认为序列长度）、步长（默认1）。切片不会因为越界而抛出异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逆序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x [::-<span class="number">1</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 末尾添加</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="built_in">len</span>(x):] = [<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除部分</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[:<span class="number">2</span>]=[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[:<span class="number">2</span>]=[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x= <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[::<span class="number">2</span>] = [<span class="number">0</span>] * (<span class="built_in">len</span>(x)//<span class="number">2</span>)  <span class="comment"># 每隔一个变为0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><p>Python中 &#x3D;&#x3D; 比较两者的值， is 比较两者的内存地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 = [<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list2 = list1[::]  <span class="comment"># 浅拷贝，修改不互相影响</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 == list2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 <span class="keyword">is</span> list2</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1          [<span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list2          [<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>常用内置函数</strong> </p><ul><li>sort() 函数改变原有对象，sort(reverse &#x3D; True) 降序排序</li><li>sorted() 函数返回新对象， sorted(list, reverse &#x3D; True) 降序，<strong>注意它的返回值永远是list类型，可以对tuple以及str等进行排序</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;ueigb&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(s)</span><br><span class="line">[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;u&#x27;</span>]  <span class="comment"># 返回排序的数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#x27;</span>.join(_)</span><br><span class="line"><span class="string">&#x27;begiu&#x27;</span>              <span class="comment"># 再加一步实现类似字符串排序的效果</span></span><br></pre></td></tr></table></figure><ul><li>reverse() 和 reversed() 同理</li><li>max(dict)、min(dict) 对字典进行比较时，使用的是key，返回的也是key；若要比较value，就用dict.values()</li><li>zip(list1, list2 …) 将多个列表或元组合为一个元组，返回一个zip对象，示例：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">zip</span>(a,b,c)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">&lt;<span class="built_in">zip</span> <span class="built_in">object</span> at <span class="number">0x00000197CD943640</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(x)               <span class="comment"># 要转成列表等才可打印</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>), (<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>), (<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>)]   <span class="comment"># 每组取一个合成</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = [<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">zip</span>(a,b,c)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(x)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>), (<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>)]   <span class="comment"># c组少一个，最终合成也少一组</span></span><br></pre></td></tr></table></figure><ul><li><p>enumerate，枚举列表、元组、字符串、字典等可迭代对象，返回多个（下标, 成员）二元组。</p></li><li><p>strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。</p><p><strong>注意：</strong>该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。</p></li></ul><p><strong>列表推导式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]  <span class="comment"># 生成偶数的平方</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">&#x27;XYZ&#x27;</span>]    <span class="comment"># 两层循环</span></span><br><span class="line">[<span class="string">&#x27;AX&#x27;</span>, <span class="string">&#x27;AY&#x27;</span>, <span class="string">&#x27;AZ&#x27;</span>, <span class="string">&#x27;BX&#x27;</span>, <span class="string">&#x27;BY&#x27;</span>, <span class="string">&#x27;BZ&#x27;</span>, <span class="string">&#x27;CX&#x27;</span>, <span class="string">&#x27;CY&#x27;</span>, <span class="string">&#x27;CZ&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vec = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[num <span class="keyword">for</span> elem <span class="keyword">in</span> vec <span class="keyword">for</span> num <span class="keyword">in</span> elem]   <span class="comment"># 嵌套列表的p</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> sqrt     <span class="comment"># 输出100以内所有的素数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[p <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">100</span>) <span class="keyword">if</span> <span class="number">0</span> <span class="keyword">not</span> <span class="keyword">in</span> [p%d <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(sqrt(p))+<span class="number">1</span>)]]</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵转置</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reverse_matrix = [[row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix[<span class="number">0</span>]))]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reverse_matrix</span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成新的3 x 4二维矩阵</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[[<span class="number">0</span>]*<span class="number">4</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]]</span><br></pre></td></tr></table></figure><h3 id="2-元组"><a href="#2-元组" class="headerlink" title="2. 元组"></a>2. 元组</h3><p>若要创建只包含一个元素的的元组，要在元素后<strong>另加一个逗号</strong>，否则会被当成数学运算中的小括号，例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = (<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(x)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = (<span class="string">&#x27;a&#x27;</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(y)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>元组访问处理的速度比列表快，若仅用于遍历访问等，则<strong>优先使用元组</strong></p><h4 id="2-1-序列解包"><a href="#2-1-序列解包" class="headerlink" title="2.1 序列解包"></a>2.1 序列解包</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x,y,x=<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>    <span class="comment"># 同时赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数传参时序列解包</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">demo</span>(<span class="params">a,b,c</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(a + b + c)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo(* s)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo(* s)   <span class="comment"># 默认操作key</span></span><br><span class="line">abc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo(** s)  <span class="comment"># 操作value值</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h4 id="2-2-生成器推导式"><a href="#2-2-生成器推导式" class="headerlink" title="2.2 生成器推导式"></a>2.2 生成器推导式</h4><p>把列表推导式的<code>[]</code>换成<code>()</code>，结果输出一个生成器类型的对象，用 __next__() 方法进行遍历。当所有元素遍历结束后，要重新建立生成器对象才能再次遍历。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = ((i+<span class="number">2</span>)**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x0000025476CCCDD0</span>&gt;  <span class="comment"># 生成器类型的对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(x)</span><br><span class="line">[<span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>, <span class="number">121</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(x) </span><br><span class="line">[]               <span class="comment"># 无法再次遍历</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = ((i+<span class="number">2</span>)**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))  <span class="comment"># 重新建立对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.__next__()   <span class="comment"># 逐步遍历</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.__next__()</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="3-字典"><a href="#3-字典" class="headerlink" title="3. 字典"></a>3. 字典</h3><p>字典的键是不可变类型，如整数、元组、字符串等。一个对象能不能作为字典的key，就取决于其有没有__hash__方法。所以所有python自带类型中，除了list、dict、set和内部至少带有上述三种类型之一的tuple之外，其余的对象都能当key。</p><p>对字典操作默认是其key，若要操作value用 .values()，若要操作键值对用 .items()</p><p>内置函数 locals() 查看当前作用域内变量和值的字典，globals() 查看全局变量和值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用zip()和dict()快速创建字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">list</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">dict</span>(<span class="built_in">zip</span>(a,b))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(name=<span class="string">&#x27;Harry&#x27;</span>,age=<span class="number">36</span>,gender=<span class="string">&#x27;Male&#x27;</span>)</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Harry&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">36</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;Male&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>.fromkeys([<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;gender&#x27;</span>])    <span class="comment"># 创建只有key没有value的字典</span></span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;age&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="literal">None</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">dict</span>(name=<span class="string">&#x27;Harry&#x27;</span>,age=<span class="number">36</span>,gender=<span class="string">&#x27;Male&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="string">&#x27;age&#x27;</span>]  <span class="comment"># 直接访问，但不推荐</span></span><br><span class="line"><span class="number">36</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.get(<span class="string">&#x27;name&#x27;</span>)   <span class="comment"># 更推荐使用get()访问</span></span><br><span class="line"><span class="string">&#x27;Harry&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.get(<span class="string">&#x27;nation&#x27;</span>)  <span class="comment"># 此时无结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.get(<span class="string">&#x27;nation&#x27;</span>,<span class="string">&#x27;China&#x27;</span>)  <span class="comment"># 无结果时可以指定返回值</span></span><br><span class="line"><span class="string">&#x27;China&#x27;</span></span><br></pre></td></tr></table></figure><p>当以指定“键”为下标为字典元素赋值时，若该“键”存在，则表示修改该“键”的值；若不存在，则表示添加一个新的“键—值对”，也就是添加一个新元素。</p><p>使用字典对象的update() 方法将另一个字典的“键值对”一次性全部添加到当前字典对象，如果两个字典中存在相同的“键”，则以另一个字典中的“值”为准对当前字典进行更新。</p><p>del() 删除指定key，pop() 删除并返回指定key，popitem() 默认删除最后一个键值对</p><h3 id="4-集合"><a href="#4-集合" class="headerlink" title="4. 集合"></a>4. 集合</h3><p><strong>集合中的元素必须是不可变类型</strong></p><p>set() 函数在创建新集合时也会进行<strong>去重</strong>，算法中可以利用这点</p><p>add() 添加一个元素，pop() 弹出并返回一个元素，remove() 删除指定元素</p><ul><li>| 或者 union() 表示并集</li><li>&amp; 或者 intersection() 表示交集</li><li>- 或者 a.difference(b) 表示差集，从a中去掉b中也有的元素</li><li>^ 或者 symmetric_difference() 表示对称差</li><li>&lt;、&gt; 的比较是看是否全部包含</li><li>issubset() 是否为子集</li></ul><p>序列越长，使用集合的效率越高</p><h3 id="5-复杂数据结构"><a href="#5-复杂数据结构" class="headerlink" title="5. 复杂数据结构"></a>5. 复杂数据结构</h3><h4 id="5-1-堆"><a href="#5-1-堆" class="headerlink" title="5.1 堆"></a>5.1 堆</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">heaqp.heappush()  <span class="comment"># 入堆（默认小根堆）</span></span><br><span class="line">heaqp.heappop()  <span class="comment"># 弹出堆顶，堆自动调整</span></span><br><span class="line">heaqp.heapify(<span class="built_in">list</span>) <span class="comment"># 调整成堆</span></span><br><span class="line">heaqp.nlargest(<span class="number">3</span>,myheap)  <span class="comment"># 最大的三个数</span></span><br><span class="line">heaqp.nsmallest(<span class="number">3</span>,myheap)  <span class="comment"># 最小的三个数</span></span><br></pre></td></tr></table></figure><h4 id="5-2-队列"><a href="#5-2-队列" class="headerlink" title="5.2 队列"></a>5.2 队列</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line">q = queue.Queue() <span class="comment"># 初始化</span></span><br><span class="line">q.put(elem)  <span class="comment"># 入队</span></span><br><span class="line">q.queue      <span class="comment"># 查看队列</span></span><br><span class="line">q.get()      <span class="comment"># 出队</span></span><br></pre></td></tr></table></figure><h4 id="5-3-栈、链表"><a href="#5-3-栈、链表" class="headerlink" title="5.3 栈、链表"></a>5.3 栈、链表</h4><p>Python自带的list类型可以基本模拟栈和链表。更好的是自己实现模拟。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/2022/01/17/python-1/py1.jpg&quot; class=&quot;&quot;&gt;

&lt;h2 id=&quot;第一章-基础知识&quot;&gt;&lt;a href=&quot;#第一章-基础知识&quot; class=&quot;headerlink&quot; title=&quot;第一章 基础知识&quot;&gt;&lt;/a&gt;第一章 基础知识&lt;/h2&gt;&lt;h3 id=&quot;1-基础&quot;&gt;&lt;a href=&quot;#1-基础&quot; class=&quot;headerlink&quot; title=&quot;1. 基础&quot;&gt;&lt;/a&gt;1. 基础&lt;/h3&gt;&lt;p&gt;IDEA中安装Python插件，即可满足学习需要&lt;/p&gt;
&lt;p&gt;IDE中要运行一个程序，必须写好这么一行&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;string&quot;&gt;&amp;#x27;__main__&amp;#x27;&lt;/span&gt;: &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;意思是：当模块被直接运行时，以下代码块将被运行；当模块是被导入时，代码块不被运行。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Longest Path</title>
    <link href="http://yoursite.com/2021/11/06/Longest-Path/"/>
    <id>http://yoursite.com/2021/11/06/Longest-Path/</id>
    <published>2021-11-06T13:10:19.000Z</published>
    <updated>2022-04-21T12:08:03.851Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到了一道算法题，求有向无环图（DAG）的最长路径，在这里记录下我的思路和解法。</p><p>首先是图的定义，这里根据严蔚敏的《数据结构》来：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span>     <span class="comment">// 边表结点</span></span><br><span class="line">    <span class="type">int</span> adjvex;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span>      <span class="comment">// 顶点表结点</span></span><br><span class="line">    VertexType data;</span><br><span class="line">    ArcNode *firstarc;</span><br><span class="line">&#125;VNode, AdjList[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>           <span class="comment">// 邻接表</span></span><br><span class="line">    AdjList Vertices;</span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;</span><br><span class="line">&#125;ALGraph;</span><br></pre></td></tr></table></figure><span id="more"></span><p>再来大致阐述一下整体的算法思想：</p><p>由于<strong>拓扑排序</strong>序列中的结点前后有序，不会出现后面结点有指向前面结点的路径这类问题。那么利用拓扑序列，检查两两结点之间的路径长度，若用 maxPath(i) 表示最长路径，weight(i,j)表示结点间的权值，则有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxPath(v) = max&#123;maxPath(v), weight(k,v)+maxPath(k)&#125;</span><br></pre></td></tr></table></figure><p>最后比较 maxPath(i) 取最大值即可得解。</p><p>于是相应写出代码。首先是拓扑排序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> indegree[MAX_VERTEX_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">TopologicalSort</span><span class="params">(ALGraph G)</span> &#123; <span class="comment">// 若图形成环，则无拓扑序列，输出false</span></span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (p = G.vertices[i].firstarc; p; p = p-&gt;nextarc) &#123;</span><br><span class="line">            indegree[p-&gt;adjvex]++; <span class="comment">// 入度数组初始化</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stack s;</span><br><span class="line">    InitStack(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) Push(s, i); <span class="comment">// 选择入度为零的顶点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 记录已输出数目</span></span><br><span class="line">    <span class="type">int</span> res[G.vexnum];</span><br><span class="line">    <span class="keyword">while</span> (!StackEmpty(s)) &#123;</span><br><span class="line">        Pop(s, i);</span><br><span class="line">        res[count++] = i;</span><br><span class="line">        <span class="keyword">for</span> (p = G.vertices[i].firstarc; p; p = p-&gt;nextarc) &#123;</span><br><span class="line">            <span class="type">int</span> v = p-&gt;adjvex;</span><br><span class="line">            indegree[v]--; <span class="comment">// 邻接顶点的入度相应减一</span></span><br><span class="line">            <span class="keyword">if</span> (indegree[v] == <span class="number">0</span>) Push(s, v); <span class="comment">// 录入入度为零的顶点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count == G.vexnum - <span class="number">1</span>; <span class="comment">// 确认全部顶点是否进入序列中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中可得到拓扑序列res[]，之后再获得最大路径如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetMaxPath</span><span class="params">(ALGraph G)</span> &#123;</span><br><span class="line">    <span class="type">int</span> MaxPath[G.vexnum];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">        <span class="type">int</span> v2 = res[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="type">int</span> v1 = res[j];</span><br><span class="line">            <span class="keyword">for</span> (ArcNode *p = G.vertices[v1].firstarc; p; p = p-&gt;nextarc) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;adjvex == v2) &#123; <span class="comment">// v1和v2相连</span></span><br><span class="line">                    <span class="type">int</span> m = MaxPath[v1] + p-&gt;weight;</span><br><span class="line">                    MaxPath[v2] = m &gt; MaxPath[v2] ? m : MaxPath[v2]; <span class="comment">// 取较大路径</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (MaxPath[i] &gt; max) max = MaxPath[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近遇到了一道算法题，求有向无环图（DAG）的最长路径，在这里记录下我的思路和解法。&lt;/p&gt;
&lt;p&gt;首先是图的定义，这里根据严蔚敏的《数据结构》来：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; MAX_VERTEX_NUM 10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;char&lt;/span&gt; VertexType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ArcNode&lt;/span&gt;&amp;#123;&lt;/span&gt;     &lt;span class=&quot;comment&quot;&gt;// 边表结点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; adjvex;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ArcNode&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;nextarc&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;ArcNode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;VNode&lt;/span&gt;&amp;#123;&lt;/span&gt;      &lt;span class=&quot;comment&quot;&gt;// 顶点表结点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    VertexType data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ArcNode *firstarc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;VNode, AdjList[MAX_VERTEX_NUM];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;&amp;#123;&lt;/span&gt;           &lt;span class=&quot;comment&quot;&gt;// 邻接表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    AdjList Vertices;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; vexnum, arcnum;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;ALGraph;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Java 中的偏向锁、轻量级锁、重量级锁解析</title>
    <link href="http://yoursite.com/2019/08/31/java-locks/"/>
    <id>http://yoursite.com/2019/08/31/java-locks/</id>
    <published>2019-08-31T04:56:22.000Z</published>
    <updated>2022-04-21T12:08:03.872Z</updated>
    
    <content type="html"><![CDATA[<p>版权声明：本文为CSDN博主「萧萧冷」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/lengxiao1993/article/details/81568130">https://blog.csdn.net/lengxiao1993/article/details/81568130</a></p><h2 id="Java-中的锁"><a href="#Java-中的锁" class="headerlink" title="Java 中的锁"></a>Java 中的锁</h2><p>在 Java 中主要有两种加锁机制：</p><ul><li>synchronized 关键字</li><li>java.util.concurrent.Lock （Lock是一个接口，ReentrantLock是该接口一个很常用的实现）</li></ul><p>这两种机制的底层原理存在一定的差别。synchronized 关键字通过一对字节码指令 monitorenter&#x2F;monitorexit 实现， 这对指令被 JVM 规范所描述。java.util.concurrent.Lock 通过 Java 代码搭配 sun.misc.Unsafe 中的本地调用实现锁。</p><span id="more"></span><h2 id="一些先修知识"><a href="#一些先修知识" class="headerlink" title="一些先修知识"></a>一些先修知识</h2><h4 id="先修知识-1：Java-对象头"><a href="#先修知识-1：Java-对象头" class="headerlink" title="先修知识 1：Java 对象头"></a>先修知识 1：Java 对象头</h4><p>字宽（Word）: 内存大小的单位概念， 对于 32 位处理器 1 Word &#x3D; 4 Bytes， 64 位处理器 1 Word &#x3D; 8 Bytes</p><p>每一个 Java 对象都至少占用 2 个字宽的内存（数组类型占用3个字宽）。第一个字宽也被称为对象头 Mark Word。 对象头包含了多种不同的信息， 其中就包含对象锁相关的信息。第二个字宽是指向定义该对象类信息（class metadata）的指针。</p><p>非数组类型的对象头的结构如下图：</p><img src="/2019/08/31/java-locks/markword.png" class="" title="对象头结构"><p>说明：</p><ul><li>MarkWord 中包含对象 hashCode 的那种无锁状态是偏向机制被禁用时， 分配出来的无锁对象MarkWord 起始状态。</li><li>偏向机制被启用时，分配出来的对象状态是 ThreadID|Epoch|age|1|01, ThreadID 为空时标识对象尚未偏向于任何一个线程， ThreadID 不为空时， 对象既可能处于偏向特定线程的状态， 也有可能处于已经被特定线程占用完毕释放的状态， 需结合 Epoch 和其他信息判断对象是否允许再偏向（rebias）。</li></ul><p>下面的图片来自参考论文 <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.94.8487&rep=rep1&type=pdf">Eliminating Synchronization-Related Atomic Operations with Biased Locking and Bulk Rebiasing</a> ， 可以与上面的表格进行比对参照， 更为清晰, 可以看出来， 标志位（tag bits）可以直接确定唯一的一种锁状态。</p><img src="/2019/08/31/java-locks/markword1.png" class="" title="对象头结构"><h4 id="先修知识-2：-CAS-指令"><a href="#先修知识-2：-CAS-指令" class="headerlink" title="先修知识 2： CAS 指令"></a>先修知识 2： <strong>CAS</strong> 指令</h4><p>CAS （Compare And Swap） 指令是一个CPU层级的原子性操作指令。 在 Intel 处理器中， 其汇编指令为 cmpxchg。</p><p>该指令概念上存在 3 个参数， 第一个参数【目标地址】， 第二个参数【值1】， 第三个参数【值2】， 指令会比较【目标地址存储的内容】和 【值1】 是否一致， 如果一致， 则将【值 2】 填写到【目标地址】， 其语义可以用如下的伪代码表示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function cas(p , old , new ) returns bool &#123;</span><br><span class="line">    if *p ≠ old &#123; // *p 表示指针p所指向的内存地址</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    *p ← new</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： 该指令是是原子性的， 也就是说 CPU 执行该指令时， 是不会被中断执行其他指令的。</p><h4 id="先修知识-3：-“CAS”实现的”无锁“算法常见误区"><a href="#先修知识-3：-“CAS”实现的”无锁“算法常见误区" class="headerlink" title="先修知识 3： “CAS”实现的”无锁“算法常见误区"></a>先修知识 3： “<strong>CAS</strong>”实现的”<strong>无锁</strong>“算法常见误区</h4><p><strong>误区一</strong>： 通过简单应用 “比较后再赋值”的操作即可轻松实现很多无锁算法</p><p>CAS 指令的一个不可忽略的特征是<strong>原子性</strong>。 在 CPU 层面， CAS 指令的执行是有原子性语义保证的， 如果 CAS 操作放在应用层面来实现， 则需要我们自行保证其原子性。 否则就会发生如下描述的问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 下列的函数如果不是线程互斥的, 是错误的 CAS 实现</span><br><span class="line">function cas( p , old , new) returns bool &#123;</span><br><span class="line">    if *p ≠ old &#123; // 此处的比较操作进行时， 可以同时有多个线程通过该判断</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    *p ← new // 多个线程的赋值操作会相互覆盖， 造成程序逻辑的错误</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>误区二</strong>： CAS 操作的 ABA 问题</p><p>大部分网络博文对 ABA 问题的常见描述是： 应用 CAS 操作时， 目标地址的值刚开始为 A， 工作线程&#x2F;进程 读取后， 进行了一系列运算， 计算得出了新值 C， 在此期间， 目标地址的值被其他线程已经进行了不止一次修改， 其值已经从 A 被改为 B ， 又改回 A， 此时便会发生同步问题。<br>上面的描述是其实是错误的， 思考一下就会发现， 如果工作线程的操作目的是将目标地址的值从 A 改为 C， 那么即便在这期间目标地址的值经过了其他线程或进程的多次修改， 其语义依旧是正确的。<br>例如目前要将某银行账号的余额扣除 50， 通过 CAS 保证同步 ：</p><ul><li>首先读取原有余额为 100 ，</li><li>计算余额应该赋值为 100 - 50 &#x3D; 50，</li><li>此时该线程被挂起， 该账户同时又发生了转入 150 和转出 150 的操作， 余额经历了 100 -&gt;250 -&gt;100 的变动</li><li>线程被唤醒， 进行 CAS 赋值操作 cas（p， 100， 50），正常得以执行。</li><li>该账户的余额依旧是正确的。</li></ul><p>通过上述例子就可以发现， ABA 的问题并不在于多次修改。 查阅一下 CAS 的 wiki 解释， 就会发现， ABA 真正的问题是， 假如目标地址的内容被多次修改以后， 虽然从二进制上来看是依旧是 A， 但是其语义已经不是 A 。例如， 发生了整数溢出， 内存回收等等。</p><h4 id="先修知识-4：-栈帧（Stack-Frame）的概念"><a href="#先修知识-4：-栈帧（Stack-Frame）的概念" class="headerlink" title="先修知识 4： 栈帧（Stack Frame）的概念"></a>先修知识 4： 栈帧（Stack Frame）的概念</h4><p>这个概念涉及的内容较多， 不便于展开叙述。 从理解下文的角度上来讲， 需要知道， 每个线程都有自己独立的内存空间， 栈帧就是其中的一部分。里面可以存储仅属于该线程的一些信息。</p><p>需要深入了解的同学， 需要自行查阅 <strong>栈帧</strong> 相关的概念。</p><h4 id="先修知识-5：-轻量级加锁的过程"><a href="#先修知识-5：-轻量级加锁的过程" class="headerlink" title="先修知识 5： 轻量级加锁的过程"></a>先修知识 5： <strong>轻量级加锁</strong>的过程</h4><p>轻量级加锁的过程在<strong>参考文章一</strong>中有较为的描述以及配图， 这里直接将其摘抄过来， 做轻微整理和调整。</p><p>（1）在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。</p><p>（2）拷贝对象头中的Mark Word复制到锁记录中。这时候线程堆栈与对象头的状态如下图所示。</p><img src="/2019/08/31/java-locks/before.png" class="" title="栈与对象头"><p>（3）拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤（4），否则执行步骤（5）。</p><p>（4）如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如下图所示。</p><img src="/2019/08/31/java-locks/after.png" class="" title="栈与对象头"><p>（5）如果这个更新操作失败了，说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁。</p><h4 id="先修知识-6：-重量级加锁的过程"><a href="#先修知识-6：-重量级加锁的过程" class="headerlink" title="先修知识 6： 重量级加锁的过程"></a>先修知识 6： <strong>重量级加锁</strong>的过程</h4><p>轻量级锁在向重量级锁膨胀的过程中， 一个操作系统的互斥量（mutex）和条件变量( condition variable )会和这个被锁的对象关联起来。</p><p>具体而言， 在锁膨胀时， 被锁对象的 markword 会被通过 CAS 操作尝试更新为一个数据结构的指针， 这个数据结构中进一步包含了指向操作系统互斥量(mutex) 和 条件变量（condition variable） 的指针。</p><h2 id="synchronized-关键字之锁的升级（偏向锁-gt-轻量级锁-gt-重量级锁）"><a href="#synchronized-关键字之锁的升级（偏向锁-gt-轻量级锁-gt-重量级锁）" class="headerlink" title="synchronized 关键字之锁的升级（偏向锁-&gt;轻量级锁-&gt;重量级锁）"></a>synchronized 关键字之锁的升级（偏向锁-&gt;轻量级锁-&gt;重量级锁）</h2><p>前面提到过， synchronized 代码块是由一对 monitorenter&#x2F;moniterexit 字节码指令实现， monitor 是其同步实现的基础， Java SE1.6 为了改善性能， 使得 JVM 会根据竞争情况， 使用如下 3 种不同的锁机制：</p><ul><li>偏向锁（Biased Lock ）</li><li>轻量级锁（ Lightweight Lock）</li><li>重量级锁（Heavyweight Lock）</li></ul><p>上述这三种机制的切换是根据竞争激烈程度进行的， 在几乎无竞争的条件下， 会使用偏向锁， 在轻度竞争的条件下， 会由偏向锁升级为轻量级锁， 在重度竞争的情况下， 会升级到重量级锁。</p><p>注意 JVM 提供了关闭偏向锁的机制， JVM 启动命令指定如下参数即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:-UseBiasedLocking</span><br></pre></td></tr></table></figure><p>下图展现了一个对象在创建（allocate） 后， 根据偏斜锁机制是否打开， 对象 Mark Word 状态以不同方式转换的过程。</p><img src="/2019/08/31/java-locks/change.jpg" class="" title="对象头的变化"><p>上图在参考文章一中的中文翻译对照图如下。</p><img src="/2019/08/31/java-locks/translate.png" class="" title="对象头的变化"><h2 id="无锁-gt-偏向锁"><a href="#无锁-gt-偏向锁" class="headerlink" title="无锁 -&gt; 偏向锁"></a>无锁 -&gt; 偏向锁</h2><img src="/2019/08/31/java-locks/1.png" class="" title="Mark Word 的变化"><p>从上图可以看到 ， 偏向锁的获取方式是将对象头的 <strong>MarkWord</strong> 部分中， 标记上线程ID， 以表示哪一个线程获得了偏向锁。 具体的赋值逻辑如下：</p><p>（1）首先读取目标对象的 MarkWord, 判断是否处于可偏向的状态（如下图）：</p><img src="/2019/08/31/java-locks/2.jpg" class="" title="可偏向的 Mark Word"><p>下面是 <a href="http://hg.openjdk.java.net/">Open Jdk&#x2F; JDK 8 源码</a> 中检测一个对象是否处于可偏向状态的源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Indicates that the mark has the bias bit set but that it has not</span></span><br><span class="line">  <span class="comment">// yet been biased toward a particular thread</span></span><br><span class="line">  <span class="type">bool</span> <span class="title function_">is_biased_anonymously</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (has_bias_pattern() &amp;&amp; (biased_locker() == <span class="literal">NULL</span>));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>（2）如果为可偏向状态, 则尝试用 CAS 操作， 将自己的线程 ID 写入 Mark Word。</p><ul><li><p>如果 CAS 操作成功（状态转变为下图）， 则认为已经获取到该对象的偏向锁， 执行同步块代码 。 注意， age 后面的标志位中的值并没有变化， 这点之后会用到。</p><img src="/2019/08/31/java-locks/3.jpg" class="" title="Mark Word"></li><li><p>补充： 一个线程在执行完同步代码块以后， 并不会尝试将 Mark Word 中的 thread ID 赋回原值 。这样做的好处是： 如果该线程需要再次对这个对象加锁，而这个对象之前一直没有被其他线程尝试获取过锁，依旧停留在可偏向的状态下， 即可在不修改对象头的情况下， 直接认为偏向成功。</p></li><li><p>如果 CAS 操作失败， 则说明， 有另外一个线程 Thread B 抢先获取了偏向锁。 这种状态说明该对象的竞争比较激烈， 此时需要撤销 Thread B 获得的偏向锁，将 Thread B 持有的锁升级为轻量级锁。 该操作需要等待全局安全点 JVM safepoint ( 此时间点， 没有线程在执行字节码) 。</p></li></ul><p>（3）如果是<strong>已偏向状态</strong>， 则检测 MarkWord 中存储的 thread ID 是否等于当前 thread ID 。</p><ul><li>如果相等， 则证明本线程已经获取到偏向锁， 可以直接继续执行同步代码块。</li><li>如果不等， 则证明该对象目前偏向于其他线程， 需要<strong>撤销</strong>偏向锁。</li></ul><p>从上面的偏向锁机制描述中，可以注意到：偏向锁的 <strong>撤销（revoke）</strong> 是一个很特殊的操作， 为了执行撤销操作， 需要等待全局安全点（Safe Point）， 此时间点所有的工作线程都停止了<strong>字节码</strong>的执行。</p><h2 id="偏向锁的撤销（Revoke）"><a href="#偏向锁的撤销（Revoke）" class="headerlink" title="偏向锁的撤销（Revoke）"></a>偏向锁的撤销（Revoke）</h2><p>如上文提到的， 偏向锁的撤销（Revoke） 操作并不是将对象恢复到无锁可偏向的状态， 而是在偏向锁的获取过程中， 发现了竞争时， 直接将一个被偏向的对象“升级到” 被加了轻量级锁的状态。 这个操作的具体完成方式如下：</p><ul><li>在偏向锁 CAS 更新操作失败以后， 等待到达全局安全点。</li><li>通过 Mark Word 中已经存在的 Thread Id 找到成功获取了偏向锁的那个线程, 然后在该线程的栈帧中补充上轻量级加锁时， 会保存的锁记录（Lock Record）， 然后将被获取了偏向锁对象的 Mark Word 更新为指向这条锁记录的指针。</li><li>至此， 锁撤销操作完成， 阻塞在安全点的线程可以继续执行。</li></ul><h2 id="偏向锁的批量再偏向（Bulk-Rebias）机制"><a href="#偏向锁的批量再偏向（Bulk-Rebias）机制" class="headerlink" title="偏向锁的批量再偏向（Bulk Rebias）机制"></a>偏向锁的批量再偏向（Bulk Rebias）机制</h2><p>偏向锁这个机制很特殊， 别的锁在执行完同步代码块后， 都会有释放锁的操作， 而偏向锁并没有直观意义上的“释放锁”操作。</p><p>那么作为开发人员， 很自然会产生的一个问题就是， 如果一个对象先偏向于某个线程， 执行完同步代码后， 另一个线程就不能直接重新获得偏向锁吗？ 答案是可以， JVM 提供了批量再偏向机制（Bulk Rebias）机制。</p><p>该机制的主要工作原理如下：</p><ul><li>引入一个概念 epoch, 其本质是一个时间戳 ， 代表了偏向锁的有效性</li><li>从前文描述的对象头结构中可以看到， epoch 存储在可偏向对象的 Mark Word 中</li><li>除了对象中的 epoch, 对象所属的类 class 信息中， 也会保存一个 epoch 值</li><li>每当遇到一个全局安全点时， 如果要对 class C 进行批量再偏向， 则首先对 class C 中保存的 epoch 进行增加操作， 得到一个新的 epoch_new</li><li>然后扫描所有持有 class C 实例的线程栈， 根据线程栈的信息判断出该线程是否锁定了该对象， 仅将 epoch_new 的值赋给被锁定的对象中。</li><li>退出安全点后， 当有线程需要尝试获取偏向锁时， 直接检查 class C 中存储的 epoch 值是否与目标对象中存储的 epoch 值相等， 如果不相等， 则说明该对象的偏向锁已经无效了， 可以尝试对此对象重新进行偏向操作。</li></ul><p>上述的逻辑可以在 JDK 源码中得到验证。见 <a href="http://hg.openjdk.java.net/jdk/jdk/file/6659a8f57d78/src/hotspot/share/runtime/sharedRuntime.cpp">sharedRuntime.cpp</a></p><p>在 sharedRuntime.cpp 中， 下面代码是 synchronized 的主要逻辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Handle <span class="title">h_obj</span><span class="params">(THREAD, obj)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="comment">// Retry fast entry if bias is revoked to avoid unnecessary inflation</span></span><br><span class="line">    ObjectSynchronizer::<span class="built_in">fast_enter</span>(h_obj, lock, <span class="literal">true</span>, CHECK);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ObjectSynchronizer::<span class="built_in">slow_enter</span>(h_obj, lock, CHECK);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>UseBiasedLocking 是 JVM 启动时， 偏向锁是否启用的标志。</li><li>fast_enter 中包含了偏向锁的相关逻辑</li><li>slow_enter 中绕过偏向锁， 直接进入轻量级锁获取</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectSynchronizer::fast_enter</span><span class="params">(Handle obj, BasicLock* lock,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">bool</span> attempt_rebias, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!SafepointSynchronize::<span class="built_in">is_at_safepoint</span>()) &#123;</span><br><span class="line">      BiasedLocking::Condition cond = BiasedLocking::<span class="built_in">revoke_and_rebias</span>(obj, attempt_rebias, THREAD);</span><br><span class="line">      <span class="keyword">if</span> (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">assert</span>(!attempt_rebias, <span class="string">&quot;can not rebias toward VM thread&quot;</span>);</span><br><span class="line">      BiasedLocking::<span class="built_in">revoke_at_safepoint</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(!obj-&amp;gt;<span class="built_in">mark</span>()-&amp;gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;biases should be revoked by now&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">slow_enter</span>(obj, lock, THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数中再次保险性地做了偏斜锁是否开启的检查（UseBiasedLocking）。</p><p>当系统不处于安全点时， 代码通过方法 revoke_and_rebias 这个函数尝试获取偏斜锁， 如果获取成功就可以直接返回了， 如果不成功则进入轻量级锁的获取过程。</p><p>revoke_and_rebias 这个函数名称就很有意思， 说明该函数中包含了 revoke 的操作也包含了 rebias 的操作。<br>可 revoke 不是只应该在安全点时刻才发生吗？ 答案是，有一些特殊情形， 不需要安全点也可以执行 revoke 操作。</p><p>那么此处为什么只有 rebias 操作， 没有初次的 bias 操作？答案：首次的 bias 操作也被当成了 rebias 操作的一个特例。</p><p>revoke_and_rebias 函数的定义在 <a href="http://hg.openjdk.java.net/jdk/jdk/file/6659a8f57d78/src/hotspot/share/runtime/biasedLocking.cpp">biasedLocking.cpp</a> 中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiasedLocking::Condition <span class="title">BiasedLocking::revoke_and_rebias</span><span class="params">(Handle obj, <span class="type">bool</span> attempt_rebias, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(!SafepointSynchronize::<span class="built_in">is_at_safepoint</span>(), <span class="string">&quot;must not be called while at safepoint&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We can revoke the biases of anonymously-biased objects</span></span><br><span class="line">  <span class="comment">// efficiently enough that we should not cause these revocations to</span></span><br><span class="line">  <span class="comment">// update the heuristics because doing so may cause unwanted bulk</span></span><br><span class="line">  <span class="comment">// revocations (which are expensive) to occur.</span></span><br><span class="line">  markOop mark = obj-&gt;<span class="built_in">mark</span>();</span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;<span class="built_in">is_biased_anonymously</span>() &amp;&amp; !attempt_rebias) &#123;</span><br><span class="line">      <span class="comment">/* </span></span><br><span class="line"><span class="comment">    进一步查看源码可得知， is_biased_anonymously() 为 true 的条件是对象处于可偏向状态， </span></span><br><span class="line"><span class="comment">    且 线程ID  为空， 表示尚未偏向于任意一个线程。 </span></span><br><span class="line"><span class="comment">    此分支是进行对象的 hashCode 计算时会进入的， 根据 markWord 结构可以看到， </span></span><br><span class="line"><span class="comment">    当一个对象处于可偏向状态时， markWord 中 hashCode 的存储空间是被占用的</span></span><br><span class="line"><span class="comment">    所以需要 revoke 可偏向状态， 以提供存储 hashCode 的空间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// We are probably trying to revoke the bias of this object due to</span></span><br><span class="line">    <span class="comment">// an identity hash code computation. Try to revoke the bias</span></span><br><span class="line">    <span class="comment">// without a safepoint. This is possible if we can successfully</span></span><br><span class="line">    <span class="comment">// compare-and-exchange an unbiased header into the mark word of</span></span><br><span class="line">    <span class="comment">// the object, meaning that no other thread has raced to acquire</span></span><br><span class="line">    <span class="comment">// the bias of the object.</span></span><br><span class="line">    markOop biased_value       = mark;</span><br><span class="line">    markOop unbiased_prototype = markOopDesc::<span class="built_in">prototype</span>()-&gt;<span class="built_in">set_age</span>(mark-&gt;<span class="built_in">age</span>());</span><br><span class="line">    markOop res_mark = obj-&gt;<span class="built_in">cas_set_mark</span>(unbiased_prototype, mark);</span><br><span class="line">    <span class="keyword">if</span> (res_mark == biased_value) &#123;</span><br><span class="line">      <span class="keyword">return</span> BIAS_REVOKED;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">    Klass* k = obj-&gt;<span class="built_in">klass</span>();</span><br><span class="line">    markOop prototype_header = k-&gt;<span class="built_in">prototype_header</span>();</span><br><span class="line">    <span class="keyword">if</span> (!prototype_header-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">      <span class="comment">// This object has a stale bias from before the bulk revocation</span></span><br><span class="line">      <span class="comment">// for this data type occurred. It&#x27;s pointless to update the</span></span><br><span class="line">      <span class="comment">// heuristics at this point so simply update the header with a</span></span><br><span class="line">      <span class="comment">// CAS. If we fail this race, the object&#x27;s bias has been revoked</span></span><br><span class="line">      <span class="comment">// by another thread so we simply return and let the caller deal</span></span><br><span class="line">      <span class="comment">// with it.</span></span><br><span class="line">      markOop biased_value       = mark;</span><br><span class="line">      markOop res_mark = obj-&gt;<span class="built_in">cas_set_mark</span>(prototype_header, mark);</span><br><span class="line">      <span class="built_in">assert</span>(!obj-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;even if we raced, should still be revoked&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> BIAS_REVOKED;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prototype_header-&gt;<span class="built_in">bias_epoch</span>() != mark-&gt;<span class="built_in">bias_epoch</span>()) &#123; </span><br><span class="line">      <span class="comment">// The epoch of this biasing has expired indicating that the</span></span><br><span class="line">      <span class="comment">// object is effectively unbiased. Depending on whether we need</span></span><br><span class="line">      <span class="comment">// to rebias or revoke the bias of this object we can do it</span></span><br><span class="line">      <span class="comment">// efficiently enough with a CAS that we shouldn&#x27;t update the</span></span><br><span class="line">      <span class="comment">// heuristics. This is normally done in the assembly code but we</span></span><br><span class="line">      <span class="comment">// can reach this point due to various points in the runtime</span></span><br><span class="line">      <span class="comment">// needing to revoke biases.</span></span><br><span class="line">      <span class="keyword">if</span> (attempt_rebias) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">下面的代码就是尝试通过 CAS 操作， 将本线程的 ThreadID 尝试写入对象头中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="built_in">assert</span>(THREAD-&gt;<span class="built_in">is_Java_thread</span>(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">        markOop biased_value       = mark;</span><br><span class="line">        markOop rebiased_prototype = markOopDesc::<span class="built_in">encode</span>((JavaThread*) THREAD, mark-&gt;<span class="built_in">age</span>(), prototype_header-&gt;<span class="built_in">bias_epoch</span>());</span><br><span class="line">        markOop res_mark = obj-&gt;<span class="built_in">cas_set_mark</span>(rebiased_prototype, mark);</span><br><span class="line">        <span class="keyword">if</span> (res_mark == biased_value) &#123;</span><br><span class="line">          <span class="keyword">return</span> BIAS_REVOKED_AND_REBIASED;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        markOop biased_value       = mark;</span><br><span class="line">        markOop unbiased_prototype = markOopDesc::<span class="built_in">prototype</span>()-&gt;<span class="built_in">set_age</span>(mark-&gt;<span class="built_in">age</span>());</span><br><span class="line">        markOop res_mark = obj-&gt;<span class="built_in">cas_set_mark</span>(unbiased_prototype, mark);</span><br><span class="line">        <span class="keyword">if</span> (res_mark == biased_value) &#123;</span><br><span class="line">          <span class="keyword">return</span> BIAS_REVOKED;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="偏向锁-gt-轻量级锁"><a href="#偏向锁-gt-轻量级锁" class="headerlink" title="偏向锁 -&gt; 轻量级锁"></a>偏向锁 -&gt; 轻量级锁</h2><p>从之前的描述中可以看到， 存在超过一个线程竞争某一个对象时， 会发生偏向锁的撤销操作。 有趣的是， 偏向锁撤销后， 对象可能处于两种状态。</p><ul><li>一种是<strong>不可偏向的无锁状态</strong>， 如下图（之所以不允许偏向， 是因为已经检测到了多于一个线程的竞争， 升级到了轻量级锁的机制）。</li></ul><img src="/2019/08/31/java-locks/11.jpg" class="" title="不可偏向的无锁状态"><ul><li>另一种是<strong>不可偏向的已锁 ( 轻量级锁) 状态</strong>。</li></ul><img src="/2019/08/31/java-locks/22.jpg" class="" title="不可偏向的已锁状态"><p>之所以会出现上述两种状态， 是因为偏向锁不存在解锁的操作， 只有撤销操作。 触发撤销操作时：</p><ul><li>原来已经获取了偏向锁的线程可能已经执行完了同步代码块， 使得对象处于 “闲置状态”，相当于原有的偏向锁已经过期无效了。此时该对象就应该被直接转换为不可偏向的无锁状态。</li><li>原来已经获取了偏向锁的线程也可能尚未执行完同步代码块， 偏向锁依旧有效， 此时对象就应该被转换为被轻量级加锁的状态。</li></ul><p><strong>轻量级加锁过程</strong>：</p><ul><li>首先根据标志位判断出对象状态处于不可偏向的无锁状态。</li><li>在当前线程的栈桢（Stack Frame）中创建用于存储锁记录（lock record）的空间，并将对象头中的Mark Word 复制到锁记录中，官方称为Displaced Mark Word。</li><li>然后线程尝试使用 CAS 操作将对象头中的 Mark Word 替换为指向锁记录的指针。<ul><li>如果成功，当前线程获得锁；</li><li>如果失败，表示该对象已经被加锁了， 先进行自旋操作， 再次尝试 CAS 争抢， 如果仍未争抢到， 则进一步升级锁至重量级锁。</li></ul></li></ul><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>重量级锁依赖于操作系统的互斥量（mutex） 实现， 其具体的详细机制此处暂不展开， 日后可能补充。 此处暂时只需要了解该操作会导致进程从用户态与内核态之间的切换， 是一个开销较大的操作。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://www.cnblogs.com/paddix/p/5405678.html">Java并发编程：Synchronized底层优化（偏向锁、轻量级锁）</a></li><li><a href="http://www.infoq.com/cn/articles/java-se-16-synchronized">聊聊并发（二）Java SE1.6中的Synchronized</a></li><li><a href="http://jpbempel.blogspot.com/2013/03/lock-lock-lock-enter.html">Lock Lock Lock: Enter!</a></li><li><a href="https://blog.takipi.com/5-things-you-didnt-know-about-synchronization-in-java-and-scala/">5 Things You Didn’t Know About Synchronization in Java and Scala</a></li><li><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">Synchronization and Object Locking</a></li><li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.94.8487&rep=rep1&type=pdf">Eliminating Synchronization-Related Atomic Operations with Biased Locking and Bulk Rebiasing</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;版权声明：本文为CSDN博主「萧萧冷」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。&lt;br&gt;原文链接：&lt;a href=&quot;https://blog.csdn.net/lengxiao1993/article/details/81568130&quot;&gt;https://blog.csdn.net/lengxiao1993/article/details/81568130&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Java-中的锁&quot;&gt;&lt;a href=&quot;#Java-中的锁&quot; class=&quot;headerlink&quot; title=&quot;Java 中的锁&quot;&gt;&lt;/a&gt;Java 中的锁&lt;/h2&gt;&lt;p&gt;在 Java 中主要有两种加锁机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;synchronized 关键字&lt;/li&gt;
&lt;li&gt;java.util.concurrent.Lock （Lock是一个接口，ReentrantLock是该接口一个很常用的实现）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两种机制的底层原理存在一定的差别。synchronized 关键字通过一对字节码指令 monitorenter&amp;#x2F;monitorexit 实现， 这对指令被 JVM 规范所描述。java.util.concurrent.Lock 通过 Java 代码搭配 sun.misc.Unsafe 中的本地调用实现锁。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁</title>
    <link href="http://yoursite.com/2019/08/03/lock/"/>
    <id>http://yoursite.com/2019/08/03/lock/</id>
    <published>2019-08-03T06:42:57.000Z</published>
    <updated>2022-04-21T12:08:03.891Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/08/03/lock/lock.jpg" class="" title="Photo by Josh Appel on Unsplash"><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>在 Java 开发过程中，锁是非常常见的，如 synchronized、ReentrantLock等，一般我们用其在多线程环境中控制对资源的并发访问。在一个单机环境中实现锁比较简单，因为多线程之间可以共享内存，因此可以简单的采取内存作为标记存储位置。而在分布式环境中，多线程变成了<strong>多进程</strong>，我们原本布置的锁将在这种场景下失效。因此，分布式锁就应运而生了。</p><span id="more"></span><h2 id="2-分布式锁概述"><a href="#2-分布式锁概述" class="headerlink" title="2. 分布式锁概述"></a>2. 分布式锁概述</h2><h3 id="2-1-为什么需要分布式锁？"><a href="#2-1-为什么需要分布式锁？" class="headerlink" title="2.1 为什么需要分布式锁？"></a>2.1 为什么需要分布式锁？</h3><p>Martin Kleppmann 是英国剑桥大学的分布式系统的研究员，之前和 Redis 之父 Antirez 进行过关于 RedLock （红锁，后续有讲到）是否安全的激烈讨论。Martin 认为一般我们使用分布式锁有两个场景:</p><ul><li>效率：使用分布式锁可以避免不同节点重复相同的工作，这些工作会浪费资源。比如用户付了钱之后有可能不同节点会发出多封短信。</li><li>正确性：加分布式锁同样可以避免破坏正确性的发生，如果两个节点在同一条数据上面操作，比如多个节点机器对同一个订单操作不同的流程有可能会导致该笔订单最后状态出现错误，造成损失。</li></ul><h3 id="2-2-我们需要怎样的分布式锁？"><a href="#2-2-我们需要怎样的分布式锁？" class="headerlink" title="2.2 我们需要怎样的分布式锁？"></a>2.2 我们需要怎样的分布式锁？</h3><ul><li>互斥性：和我们本地锁一样互斥性是最基本，但是分布式锁需要保证在不同节点的不同线程的互斥，即同一个方法在同一时间只能被一台机器上的一个线程执行；</li><li>可重入性：同一个节点上的同一个线程如果获取了锁之后那么也可以再次获取这个锁（避免死锁）；</li><li>锁超时：和本地锁一样支持锁超时，防止死锁；</li><li>高效，高可用：加锁和解锁需要高效，同时也需要保证高可用性，防止分布式锁失效，可以增加降级；</li><li>支持阻塞和非阻塞：和 ReentrantLock 一样支持 lock 和 trylock 以及 tryLock(long timeOut)。</li><li>支持公平锁和非公平锁（可选）：公平锁的意思是按照请求加锁的顺序获得锁，非公平锁就相反是无序的。这个一般来说实现的比较少。</li></ul><h3 id="2-3-分布式锁的实现"><a href="#2-3-分布式锁的实现" class="headerlink" title="2.3 分布式锁的实现"></a>2.3 分布式锁的实现</h3><p>分布式的 CAP 理论告诉我们：任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要<strong>牺牲强一致性</strong>来换取系统的<strong>高可用性</strong>，系统往往只需要保证“最终一致性”，只要是在用户可以接受的范围内即可。</p><p>一般来说，分布式锁的实现有以下几个方式：</p><ul><li>基于数据库（MySQL）实现；</li><li>基于缓存（Redis）实现；</li><li>基于 Zookeeper 实现。</li></ul><p>这三种方案没有绝对的好坏之分，需要根据场景选择最适合的实现方式。</p><h2 id="3-基于数据库实现分布式锁"><a href="#3-基于数据库实现分布式锁" class="headerlink" title="3. 基于数据库实现分布式锁"></a>3. 基于数据库实现分布式锁</h2><p>数据库在日常开发中十分常见，因此利用 MySQL 实现的分布式锁相对也比较简单、易理解。首先要建立一张这样的数据库表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `methodLock` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `method_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;锁定的方法名&#x27;</span>,</span><br><span class="line">  `<span class="keyword">desc</span>` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;备注信息&#x27;</span>,</span><br><span class="line">  `update_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;保存数据时间，自动生成&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uidx_method_name` (`method_name `) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;锁定中的方法&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="3-1-基于数据库表"><a href="#3-1-基于数据库表" class="headerlink" title="3.1 基于数据库表"></a>3.1 基于数据库表</h3><p>当我们要锁住某个方法时，执行以下 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> methodLock(method_name,<span class="keyword">desc</span>) <span class="keyword">values</span> (‘method_name’,‘<span class="keyword">desc</span>’)</span><br></pre></td></tr></table></figure><p>因为我们对 <code>method_name</code> 做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p><p>方法执行完以后，释放锁的时候执行以下 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> methodLock <span class="keyword">where</span> method_name <span class="operator">=</span><span class="string">&#x27;method_name&#x27;</span></span><br></pre></td></tr></table></figure><p>上面的实现有几个问题：</p><ul><li>这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li><li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li><li>这把锁只能是非阻塞的，因为数据的 insert 操作一旦失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li><li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li></ul><h3 id="3-2-基于数据库排他锁"><a href="#3-2-基于数据库排他锁" class="headerlink" title="3.2 基于数据库排他锁"></a>3.2 基于数据库排他锁</h3><p>在 MySQL 的 InnoDB 引擎下，我们利用数据库排他锁实现分布式锁。</p><h4 id="3-2-1-lock"><a href="#3-2-1-lock" class="headerlink" title="3.2.1 lock()"></a>3.2.1 lock()</h4><p>lock() 方法是阻塞式的获取锁，意思就是不获取到锁誓不罢休，那么我们可以写一个死循环来执行其操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mysqlLock.lock(method))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 休眠3ms后重试</span></span><br><span class="line">        LockSupport.parkNanos(<span class="number">1000</span> * <span class="number">1000</span> * <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mysqlLock.lock() 方法内部包含一个 SQL 语句，为了达到可重入锁的效果，应该先查询是否有对应的方法名字，如果有，就需要比较 desc 是否一致，这里的 desc 可以使用机器 IP 或线程名字等来表示，如果一致就增加可重入锁 counter 的值，如果不一致就返回；如果没有这个方法就插入一条新的数据。伪代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transcation</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lock</span><span class="params">(String methodName)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(select * from methodLock <span class="type">where</span> <span class="variable">method_name</span> <span class="operator">=</span> methodName <span class="keyword">for</span> update)&#123;</span><br><span class="line">        <span class="comment">// 是否有该方法</span></span><br><span class="line">        <span class="keyword">if</span>(currentDesc == resultDesc)&#123;</span><br><span class="line">            <span class="comment">// 节点信息是否一致</span></span><br><span class="line">            update methodLock <span class="type">set</span> <span class="variable">counter</span> <span class="operator">=</span> counter + <span class="number">1</span> <span class="type">where</span> <span class="variable">method_name</span> <span class="operator">=</span> methodName;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        insert into method_name ...;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码必须加上事务，必须要保证这一系列操作的原子性。</p><p>在查询语句后面增加 <code>for update</code>，数据库会在查询过程中给数据库表增加排他锁（由于 InnoDB 引擎的性质，需要为检索的字段加上唯一索引），当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。</p><p>当然，假如我们要加锁的资源已经在数据库中了，那么也不需要建表了，直接利用 <code>for update</code> 加锁。</p><h4 id="3-2-2-tryLock-和-tryLock-long-timeout"><a href="#3-2-2-tryLock-和-tryLock-long-timeout" class="headerlink" title="3.2.2 tryLock() 和 tryLock(long timeout)"></a>3.2.2 tryLock() 和 tryLock(long timeout)</h4><p>相比较 lock()，trylock() 是非阻塞获取锁，如果获取不到那么就会马上返回，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">trylock</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mysqlLock.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryLock(long timeout) 实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">trylock</span><span class="params">(<span class="type">long</span> timeout)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis() + timeout;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mysqlLock.lock())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(endTime &gt;= System.currentTimeMillis())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 mysqlLock.lock() 实现和上面一样，但是要注意的是 <code>for update</code> 这个是阻塞获取行锁，如果同一个资源并发量较大还是有可能会退化成阻塞的获取锁。</p><p>这里还可能存在另外一个问题，虽然我们对 method_name 使用了唯一索引，并且显示使用 <code>for update</code> 来使用行级锁。但是，MySQL 会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。</p><p>还有一个问题，就是我们要使用排他锁来进行分布式锁的 lock()，那么一个排他锁长时间不提交，就会占用数据库连接。一旦类似的连接变得多了，就可能把数据库连接池撑爆。</p><h4 id="3-2-3-unlock"><a href="#3-2-3-unlock" class="headerlink" title="3.2.3 unlock()"></a>3.2.3 unlock()</h4><p>这里的解锁就是按照前面可重入锁的 counter 来实现的，伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transcation</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 表中有数据</span></span><br><span class="line">    <span class="keyword">if</span>(select * from methodLock)&#123;</span><br><span class="line">        <span class="keyword">if</span>(currentDesc == resultDesc)&#123;</span><br><span class="line">            <span class="keyword">if</span>(counter &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            counter--;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                delete;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-锁超时"><a href="#3-3-锁超时" class="headerlink" title="3.3 锁超时"></a>3.3 锁超时</h3><p>有可能集群中的一台机器挂了，分布式锁也就无法释放了。解决办法是启动一个定时任务，通过我们对于一个锁的生命周期的预期（可以计算处理任务的平局时间，再在这个时间基础上略微扩大一些），确定定时任务的周期，超过一定时间，我们就认为是机器宕机，直接将锁释放。</p><h3 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4 小结"></a>3.4 小结</h3><ul><li>优点：理解起来简单，不需要维护第三方的中间件。</li><li>缺点：实现起来比较繁琐，即使如上考虑了可重入、阻塞与非阻塞、事务以及锁超时等等，还是存在不少问题，在解决问题的过程中会使整个方案变得越来越复杂；性能收到了数据库局限；不适合高并发场景。</li></ul><h2 id="4-基于-Redis-实现分布式锁"><a href="#4-基于-Redis-实现分布式锁" class="headerlink" title="4. 基于 Redis 实现分布式锁"></a>4. 基于 Redis 实现分布式锁</h2><p>相对于基于数据库实现分布式锁的方案来说，基于缓存来实现在性能方面会表现的更好一点，存取速度快很多。而且很多缓存是可以集群部署的，可以解决单点问题。基于缓存的锁有好几种，本文下面主要讲解基于 Redis 的分布式实现。</p><h3 id="4-1-原生实现"><a href="#4-1-原生实现" class="headerlink" title="4.1 原生实现"></a>4.1 原生实现</h3><p>首先是一个最基础的版本，利用 Redis 的 <code>setnx</code> 命令来进行加锁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lockKey value NX</span><br></pre></td></tr></table></figure><p>解锁也很简单，使用 <code>del</code> 命令即可。</p><p>这样的实现有一个问题：由于某种原因，执行加锁的机器 A 挂了，这个锁就会一直存在，不能释放，其他机器永远也获得不到锁了。</p><p>问题的解决思路也很简单：为锁设置一个过期时间。类似的 Redis 命令如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lockKey value NX EX 30</span><br></pre></td></tr></table></figure><p>这里特别要注意一点，设置锁和过期时间的两个操作要保证原子性，否则机器挂了，锁还是没办法释放。（Redis 2.8 之前可以使用 Lua 脚本实现，2.8 之后支持 nx 和 ex 属于原子操作）</p><p>又有一个问题：如何保证在这个过期时间内业务可以执行完成？一个简单的解决思路是统计业务执行的最长耗时，在其基础上增加一段缓冲的时间，保证锁在任务执行完之前不会过期。但是这并没有真正解决问题。</p><p>再考虑一个场景：</p><ul><li>客户端 A 获取锁成功，过期设置为时间30秒，但它在某个操作上阻塞了50秒；</li><li>30秒时间到了，锁将会自动释放；</li><li>客户端 B 获取到了对应同一个资源的锁，开始执行自己的业务；</li><li>客户端 A 从阻塞中恢复过来，释放掉了客户端 B 持有的锁。</li></ul><p>也就是说，如何保证加锁和解锁是同一个客户端完成的呢（锁不会被误删除）？</p><p>这时，可以为每个客户端生成一个随机字符串 value，删除之前首先比较 value 的值，确认当前的锁是自己加的，那么才可以删除锁，这样就防止了误删。这个解锁操作也需要 Lua 脚本保证原子性。</p><h3 id="4-2-Redisson"><a href="#4-2-Redisson" class="headerlink" title="4.2 Redisson"></a>4.2 Redisson</h3><p>Redisson 是一个在 Redis 的基础上实现的 Java 驻内存数据网格（In-Memory Data Grid），它不仅提供了一系列的分布式的 Java 常用对象，还提供了许多分布式服务。</p><p>有关 Redisson 的分布式锁的实现，可以先看看这里的 <a href="%5Bhttps://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8%5D(https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8)">Wiki 文档</a>。下面分析一下 RedissonLock 的实现。</p><p>首先是 lock() 的基本用法，代码和注释如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.通过RedissonClient的getLock()方法获得RLock实例 </span></span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;foobar&quot;</span>);</span><br><span class="line"><span class="comment">// 2.获取分布式锁</span></span><br><span class="line">lock.lock(); </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 3.若成功获得则继续往下执行，否则等待锁的释放再尝试获取</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 4.释放锁</span></span><br><span class="line">    lock.unlock(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getLock() 的方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RLock <span class="title function_">getLock</span><span class="params">(String name)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RedissonLock</span>(commandExecutor, name, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 commandExecutor 可以与 Redis 节点进行通信并发送指令，具体是通过 <code>eval</code> 命令，来执行 Lua 脚本（要求 Redis 版本不低于 2.6）；name 是锁的全局名称；id 是客户端的唯一标识，用 UUID 表示。</p><p>再来看一看 tryLock() 方法：</p><ol><li>使用 Lua 脚本尝试加锁，保证这一操作的原子性。它使用了 Hash 结构，我们的每一个需要锁定的资源都可以看做是一个 HashMap，锁定资源的节点信息是 key，锁定次数是 value。</li></ol>   <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">then</span> </span><br><span class="line">    redis.call(<span class="string">&#x27;hset&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]) == <span class="number">1</span>) <span class="keyword">then</span> </span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">return</span> redis.call(<span class="string">&#x27;pttl&#x27;</span>, KEYS[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>   (1) 如果通过 <code>exists</code> 命令发现当前 key 不存在，即锁没被占用，则执行 <code>hset</code> 写入 Hash 类型数据 <strong>key:全局锁名称</strong>（例如共享资源ID）, <strong>field:锁实例名称</strong>（Redisson 客户端ID:线程ID）, <strong>value:1</strong>，并执行 <code>pexpire</code> 对该 key 设置失效时间，返回空值 <code>nil</code>，至此获取锁成功。</p><p>   (2) 如果通过 <code>hexists</code> 命令发现 Redis 中已经存在当前 key 和 field 的 Hash 数据，说明当前线程之前已经获取到锁，因为这里的锁是<strong>可重入</strong>的，则执行 <code>hincrby</code> 对当前 key field 的值<strong>加一</strong>，并重新设置失效时间，返回空值，至此重入获取锁成功。</p><p>   (3) 最后是锁已被占用的情况，即当前 key 已经存在，但是 Hash 中的 Field 与当前值不同，则执行 <code>pttl</code> 获取锁的剩余存活时间并返回，至此获取锁失败。</p><ol start="2"><li><p>如果获得锁，则结束流程，回去执行业务逻辑。 </p></li><li><p>如果没有获得锁，则需等待锁被释放，并通过 Redis 的 channel 订阅锁释放的消息。</p></li><li><p>订阅锁的释放消息成功后，进入一个不断重试获取锁的循环，循环中每次都先试着获取锁，并得到已存在的锁的剩余存活时间。 如果在重试中拿到了锁，则结束循环，跳过第 5 步。 </p></li><li><p>如果锁当前是被占用的，那么等待释放锁的消息，具体实现使用了 JDK 并发的信号量工具 Semaphore 来阻塞线程，当锁释放并发布释放锁的消息后，信号量的 release() 方法会被调用，此时被信号量阻塞的等待队列中的一个线程就可以继续尝试获取锁了。 </p></li><li><p>在成功获得锁后，就没必要继续订阅锁的释放消息了，因此要取消对 Redis 上相应 channel 的订阅。</p></li></ol><p>解锁的 unlock() 同样需要 Lua 脚本：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;publish&#x27;</span>, KEYS[<span class="number">2</span>], ARGV[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">3</span>]) == <span class="number">0</span>) <span class="keyword">then</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>; </span><br><span class="line"><span class="keyword">local</span> counter = redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">3</span>], <span class="number">-1</span>); </span><br><span class="line"><span class="keyword">if</span> (counter &gt; <span class="number">0</span>) <span class="keyword">then</span> </span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>]); </span><br><span class="line">    redis.call(<span class="string">&#x27;publish&#x27;</span>, KEYS[<span class="number">2</span>], ARGV[<span class="number">1</span>]); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"><span class="keyword">end</span>; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>利用 Lua 脚本来释放锁：</li></ol><p>   (1) key 不存在，说明锁已释放，直接执行 <code>publish</code> 命令发布释放锁消息并返回 <code>1</code>。</p><p>   (2) key 存在，但是 field 在 Hash 中不存在，说明自己不是锁持有者，无权释放锁，返回 <code>nil</code>。</p><p>   (3) 因为锁可重入，所以释放锁时不能把所有已获取的锁全都释放掉，一次只能释放一把锁，因此执行 <code>hincrby</code> 对锁的值<strong>减一</strong>。</p><p>   (4) 释放一把锁后，如果还有剩余的锁，则刷新锁的失效时间并返回 <code>0</code>；如果刚才释放的已经是最后一把锁，则执行 <code>del</code> 命令删除锁的 key，并发布锁释放消息，返回 <code>1</code>。</p><ol start="2"><li><p>上面执行结果返回 <code>nil</code> 时，因为自己不是锁的持有者，不允许释放别人的锁，故抛出异常。</p></li><li><p>执行结果返回 <code>1</code> 的情况，该锁的所有实例都已全部释放，所以不需要再刷新锁的失效时间。</p></li></ol><h3 id="4-3-RedLock"><a href="#4-3-RedLock" class="headerlink" title="4.3 RedLock"></a>4.3 RedLock</h3><p>想象一个的场景：当机器 A 申请到一把锁之后，如果 Redis 主机宕机了，由于主从复制是异步的，这个时候从机并没有同步到这一把锁，那么机器 B 就会再次申请到这把锁。为了解决这个问题，就有了 RedLock。RedLock 的核心思想就是，同时使用多个 Redis Master 来冗余，且这些节点都是完全的独立的，也不需要对这些节点之间的数据进行同步。</p><p>假设我们有 N 个 Redis 节点，N 应该是一个大于2的奇数。RedLock 的实现步骤如下：</p><ol><li>取得当前时间；</li><li>依次获取 N 个节点的 Redis 锁；</li><li>如果获取到的锁的数量大于 （N&#x2F;2+1）个,且获取的时间小于锁的有效时间(lock validity time)就认为获取到了一个有效的锁。锁自动释放时间就是最初的锁释放时间减去之前获取锁所消耗的时间。</li><li>如果获取锁的数量小于 （N&#x2F;2+1），或者在锁的有效时间(lock validity time)内没有获取到足够的锁，就认为获取锁失败。这个时候需要向所有节点发送释放锁的消息。</li></ol><p>对于释放锁的实现就很简单了。向所有的 Redis 节点发起释放的操作，无论之前是否获取锁成功。</p><p>可以看见 RedLock 基本原理是利用多个 Redis 集群，用多数的集群加锁成功，减少 Redis 某个集群出故障，造成分布式锁出现问题的概率。</p><h2 id="5-基于-Zookeeper-实现分布式锁"><a href="#5-基于-Zookeeper-实现分布式锁" class="headerlink" title="5. 基于 Zookeeper 实现分布式锁"></a>5. 基于 Zookeeper 实现分布式锁</h2><h3 id="5-1-基本实现"><a href="#5-1-基本实现" class="headerlink" title="5.1 基本实现"></a>5.1 基本实现</h3><p>假设我们现在有一个父节点 &#x2F;lock，实现一个分布式锁的流程大致如下：</p><ol><li>客户端连接 Zookeeper，并在 &#x2F;lock 下创建<strong>临时的</strong>且<strong>有序的</strong>子节点，第一个客户端对应的子节点为 &#x2F;lock&#x2F;lock-0000000000，第二个为 &#x2F;lock&#x2F;lock-0000000001，以此类推；</li><li>客户端获取 &#x2F;lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中<strong>序号最小</strong>的子节点，如果是则认为获得锁，否则<strong>监听刚好在自己之前一位的子节点删除消息</strong>，获得子节点变更通知后重复此步骤直至获得锁（这里有对羊群效应的优化）；</li><li>执行业务代码；</li><li>完成业务流程后，删除对应的子节点释放锁。</li></ol><p>由于创建的是临时节点，所以当某台服务器宕机时，Zookeeper 会判断与客户端的会话失败，删除结点，所以不会有锁无法解除的问题。</p><p>可能有人会有一个疑问：假设客户端 A 有对应子节点 lock-1，客户端 B 有对应子节点 lock-2，当客户端 B 获取子节点列表时发现自己不是最小的节点，准备要订阅删除消息前，客户端 A 正好删除了 lock-1，那么客户端 B 岂不是要一直等待下去了？Zookeeper 保证了不会出现这个问题，因为它的 API 提供的设置监听器的操作与读操作是<strong>原子执行</strong>的，在获取列表并判断的同时设置监听器，中间不会有其他操作，保证不会丢失事件。</p><p>使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。</p><h3 id="5-2-Curator"><a href="#5-2-Curator" class="headerlink" title="5.2 Curator"></a>5.2 Curator</h3><p>Curator 封装了 Zookeeper 底层的 API，我们可以更加方便地对 Zookeeper 进行操作，并且它封装了分布式锁的功能，这样我们就不需要再自己实现了。框架的基本使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//创建zookeeper的客户端</span></span><br><span class="line">    <span class="type">RetryPolicy</span> <span class="variable">retryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.newClient(<span class="string">&quot;10.21.41.181:2181,10.21.42.47:2181,10.21.49.252:2181&quot;</span>, retryPolicy);</span><br><span class="line">    client.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建分布式锁, 锁空间的根节点路径为/curator/lock</span></span><br><span class="line">    <span class="type">InterProcessMutex</span> <span class="variable">mutex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(client, <span class="string">&quot;/curator/lock&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    mutex.acquire();</span><br><span class="line">    <span class="comment">//获得了锁, 进行业务流程</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Enter mutex&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//完成业务流程, 释放锁</span></span><br><span class="line">    mutex.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭客户端</span></span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>本文主要讲解了几种分布式锁的实现和它们各自的问题、优缺点等，我们在实际生产过程中要根据具体场景，通过分析找到最适合的解决方案。</p><p><strong>参考资料</strong></p><ul><li><a href="https://juejin.im/post/5bbb0d8df265da0abd3533a5#heading-18">再有人问你分布式锁，这篇文章扔给他</a></li><li><a href="https://yq.aliyun.com/articles/60663">分布式锁的实现</a></li><li><a href="https://juejin.im/post/5b737b9b518825613d3894f4#comment">redis系列：分布式锁</a></li><li><a href="https://www.cnblogs.com/zhili/p/redisdistributelock.html">【分布式缓存系列】Redis实现分布式锁的正确姿势</a></li><li><a href="https://github.com/angryz/my-blog/issues/4">Redisson 分布式锁实现分析</a></li><li><a href="%5Bhttps://www.xilidou.com/2017/10/23/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%5D(https://www.xilidou.com/2017/10/23/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/)">Redis实现分布式锁</a></li><li><a href="http://www.dengshenyu.com/java/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2017/10/23/zookeeper-distributed-lock.html">基于Zookeeper的分布式锁</a></li><li><a href="https://www.hollischuang.com/archives/1716">分布式锁的几种实现方式~</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/2019/08/03/lock/lock.jpg&quot; class=&quot;&quot; title=&quot;Photo by Josh Appel on Unsplash&quot;&gt;

&lt;h2 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1. 背景&quot;&gt;&lt;/a&gt;1. 背景&lt;/h2&gt;&lt;p&gt;在 Java 开发过程中，锁是非常常见的，如 synchronized、ReentrantLock等，一般我们用其在多线程环境中控制对资源的并发访问。在一个单机环境中实现锁比较简单，因为多线程之间可以共享内存，因此可以简单的采取内存作为标记存储位置。而在分布式环境中，多线程变成了&lt;strong&gt;多进程&lt;/strong&gt;，我们原本布置的锁将在这种场景下失效。因此，分布式锁就应运而生了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Java Web 项目部署记录</title>
    <link href="http://yoursite.com/2019/06/23/deploy/"/>
    <id>http://yoursite.com/2019/06/23/deploy/</id>
    <published>2019-06-23T05:33:55.000Z</published>
    <updated>2022-04-21T12:08:03.853Z</updated>
    
    <content type="html"><![CDATA[<p>最近把自己做的一个 Java Web 项目后端部署在了 Linux 服务器上，这是<a href="https://github.com/Avicii4/emall">项目地址</a>，发布地址：<a href="http://111.231.171.22/index.jsp">http://111.231.171.22/index.jsp</a> ，由于是以学习后端为目的，所以整个项目的没有前端部分，整个项目需要依靠 Chrome 插件 Restlet Client 才可以进行测试运行。</p><p>下面主要整理一下自己在部署时遇到的值得关注的地方。</p><p><strong>服务器账号</strong></p><p>高配置的云服务器价格比较贵，阿里云和腾讯云都提供了学生套餐，基本都是 10元&#x2F;月左右，比较实惠。我申请了一台腾讯云的学生服务器，进入控制台，如下图。</p><span id="more"></span><img src="/2019/06/23/deploy/1.jpg" class="" title="服务器账号"><p>假设公网 IP 为 1.2.3.4，打开 Linux 终端，输入 <code>ssh root@1.2.3.4</code>，输入购买服务器时 root 密码，连接服务器。个人学习使用时，使用 root 账号没有问题，但在公司等实际场景中，每个人都会有自己的个人账号，并对不同的目录、文件等拥有不同的权限，这样操作的安全性更高。新建一个用户的过程是（以 harry 为例）：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">user</span> <span class="selector-tag">add</span> <span class="selector-tag">-d</span> /<span class="selector-tag">usr</span>/<span class="selector-tag">harry</span> <span class="selector-tag">-m</span> <span class="selector-tag">harry</span></span><br><span class="line"><span class="selector-tag">cd</span> /<span class="selector-tag">usr</span>/<span class="selector-tag">harry</span></span><br><span class="line"><span class="selector-tag">passwd</span> <span class="selector-tag">harry</span></span><br></pre></td></tr></table></figure><p>然后输入两次密码，进行确认。之后，用 Vim 打开 &#x2F;etc&#x2F;sudoers，找到 “ rootALL&#x3D;(ALL)ALL” 这一行，在下面加上 “ harryALL&#x3D;(ALL)ALL” ，保存，一个有 sudo 权限的新用户就创建完成了。</p><p><strong>JDK 的安装</strong></p><p>在配置 JDK 之前，首先检查购买的 Linux 服务器中有没有事先安装 OpenJDK 等，先执行<code>rpm -qa | grep jdk</code>  搜索自带的 JDK，然后用 <code>sudo yum remove xxx</code> 卸载（xxx为搜索到的结果）。</p><p>从 Oracle 官网下载用 wget 下载 JDK 包时，单纯写入 JDK 的 URL 是不够的，还需要在后面加上身份验证信息的 AuthParam 字段，完整的下载路径获取如下图所示。</p><img src="/2019/06/23/deploy/2.jpg" class="" title="JDK"><p>例如，应输入：<code>sudo wgethttps://download.oracle.com/otn/java/jdk/8u211-b12/478a62b7d4e34b78b671c754eaaf38ab/jdk-8u211-linux-x64.rpm?AuthParam=1561270126_aed4242c4a96bcf24d65badddd2ac8ee    </code> （仅用于示范）</p><p><strong>MySQL 用户设置</strong></p><p>环境配置还需要安装 MySQL，直接使用 yum 源下载。下载后，用 root 进入 MySQL，输入 <code>select user,host,password from mysql.user;</code> 查看数据库用户，初始情况下都是没有密码的，因此要设置一下。初始状态下，我的用户和 host 名如下图。</p><img src="/2019/06/23/deploy/3.jpg" class="" title="Users"><p>可以看到第二个 host 名显示时使用了转义字符 \。</p><p>对于第一个用户，输入 <code>set password for root@localhost = password(&quot;yourpassword&quot;)</code> ，到第二个用户时，输入 <code>set password for root@vm\_0\_5\_centos= password(&quot;yourpassword&quot;)</code> 却会报错，提示 SQL 语句有语法错误。原来不仅需要为通配符加上转义字符，还要给整个语句加<strong>反勾号</strong> ` `，也就是数字键 1 左边的键。正确的输入是：</p><img src="/2019/06/23/deploy/4.jpg" class="" title="SQL"><p><strong>云服务器安全组设置</strong></p><p>在服务器上部署好项目，却发现无法访问80或者8080端口，连 ping 也不通，原因之一是未配置安全组，导致服务器一个端口也没有开放出来。在腾讯云选择 更多—&gt;安全组—&gt;配置安全组，可以选择默认提供的安全组配置，也可以自行定义入站、出站规则，如下图所示。不推荐开放所有端口，最好是根据项目所需，一个个地开放。</p><img src="/2019/06/23/deploy/5.jpg" class="" title="safe"><p><strong>FTP 服务设置</strong></p><p>项目中需要通过 FTP 进行图片上传等功能，要安装 vsftpd，并配置一个 FTP 服务器用户和密码。部署项目并在线上测试时，发现上传的图片 URL 无法打开，根据 Nginx 配置的文件存放路径里也没有图片。遇到这个错误时我一筹莫展，最后尝试从 Tomcat 日志中寻找线索。果然，在 Tomcat 路径下的 logs&#x2F;catalina.out 中，发现 FTP 服务器连接失败。原来，在项目中，我将 FTP 服务器的 IP、用户和密码放在了一个 .properties 文件里，其中的信息都是我在本地测试时用到的，IP 填的是 127.0.0.1，肯定是不对的。如下图。</p><img src="/2019/06/23/deploy/6.jpg" class="" title="config"><p>所以，修改文件内容，和线上服务器里配置的一样。每一次改完 Java 项目，需要提交并 push 至线上仓库，然后再次通过 Shell 脚本更新远程 Linux 服务器中的代码，再编译，发布。然后，再次查看日志，发现这个连接失败的错误没了，不过连接超时的错误出现了。</p><p>一个可能是 vsftpd 的设置出了问题。进入修改 &#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf 文件，重点关注的字段有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">write_enable=YES      #定义写权限</span><br><span class="line">listen_port=61001     #监听端口</span><br><span class="line">ftp_data_port=61002   #数据端口</span><br><span class="line">pasv_min_port=61001   #随机最小端口</span><br><span class="line">pasv_max_port=62000   #随机最大端口</span><br></pre></td></tr></table></figure><p>如像上面配置了端口之后，还要去 &#x2F;etc&#x2F;sysconfig&#x2F;iptablesi 修改防火墙配置，添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-A OUTPUT -p tcp --sport 4000:5000 -j ACCEPT</span><br><span class="line">-A INPUT -p tcp --dport 4000:5000 -j ACCEPT</span><br></pre></td></tr></table></figure><p>设置好以后，重启 vsftpd 和 iptables。</p><p><strong>Linux 文件权限</strong></p><p>连接超时的这个错误比较棘手，会引发问题的地方很多。我进入 FTP 目录中，还是没有看到应该上传的图片。因此，我想到了文件权限的问题。由于线上图片的上传都是通过新建的 FTP 用户进行的，那假如新用户没有此文件夹的写入权限，FTP 上传也就失败了。于是为这个用户赋予权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo chown ftpuser img/</span><br><span class="line">sudo chgrp ftpuser img/</span><br><span class="line">sudo chmod g+w img/</span><br></pre></td></tr></table></figure><p><strong>Nginx 配置负载均衡</strong></p><p>项目中还用到了 Tomcat 集群，为了区别标志，检验配置是否成功，网站首页刷新还会有两个 Tomcat 的标识。使用 Nginx 反向代理本地的两个 Tomcat 服务，并且达到负载均衡的效果。编辑它的 nginx.conf 文件，默认为服务器轮询方式，添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream 111.231.171.22&#123;</span><br><span class="line">    server 127.0.0.1:8080;</span><br><span class="line">    server 127.0.0.1:9080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于两个 Tomcat 均部署在同一台机器上，所以 IP 地址直接填写本地的。而假如不在一台机器上，上述 IP 地址可以写成内网 IP（公网 IP 也可以，但是服务速度会很慢）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近把自己做的一个 Java Web 项目后端部署在了 Linux 服务器上，这是&lt;a href=&quot;https://github.com/Avicii4/emall&quot;&gt;项目地址&lt;/a&gt;，发布地址：&lt;a href=&quot;http://111.231.171.22/index.jsp&quot;&gt;http://111.231.171.22/index.jsp&lt;/a&gt; ，由于是以学习后端为目的，所以整个项目的没有前端部分，整个项目需要依靠 Chrome 插件 Restlet Client 才可以进行测试运行。&lt;/p&gt;
&lt;p&gt;下面主要整理一下自己在部署时遇到的值得关注的地方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务器账号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;高配置的云服务器价格比较贵，阿里云和腾讯云都提供了学生套餐，基本都是 10元&amp;#x2F;月左右，比较实惠。我申请了一台腾讯云的学生服务器，进入控制台，如下图。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>两个单链表相交的相关问题</title>
    <link href="http://yoursite.com/2019/05/04/crossed-linkedlist/"/>
    <id>http://yoursite.com/2019/05/04/crossed-linkedlist/</id>
    <published>2019-05-04T11:49:59.000Z</published>
    <updated>2022-04-21T12:08:03.852Z</updated>
    
    <content type="html"><![CDATA[<p>来看一道有关链表的题目：</p><p>给定两个单链表的头结点 <code>head1</code> 和 <code>head2</code>，这两个链表可能相交，也可能不相交。请实现一个函数，若两链表相交，则返回相交的第一个结点；若不相交，则返回 <code>null</code>。<br>进阶要求：如果链表1的长度为 <em>N</em>，链表2的长度为 <em>M</em>，时间复杂度请达到 *O(N+M)*，额外空间复杂度请达到 *O(1)*。</p><img src="/2019/05/04/crossed-linkedlist/cross1.png" class=""><p>如上所示，根据题意可以立刻画出一个单链表相交的示意图。</p><span id="more"></span><p>这里需要注意，不可能画出如下所示的相交示意图，因为此题规定了<strong>单链表</strong>，而如下图所示的链表中必有一个结点（图中用红色标出）拥有两条指针，这违反了单链表的定义。这里也可以得到一个重要结论：<strong>两条链表的尾结点一定是相同的</strong>。</p><img src="/2019/05/04/crossed-linkedlist/impossible.png" class=""><p>那么根据第一张图的情况，如何求得相交的第一个节点呢？</p><p>第一个思路：将第一个链表的结点插入一个 HashSet 中，再将第二个链表结点插入，若插入过程中函数返回 false，则两个链表有相交，立刻返回此时的结点。这种思路极易想到，但它不满足空间复杂度的进阶要求。</p><p>第二个思路也比较好理解：让两个指针分别遍历一遍两个链表，得到两个链表的长度，将其相减，得到它们的差，设为 <em>L</em>。然后两个指针回到起点，较长的那个链表上的指针先走 <em>L</em> 步，接下来两个指针一起走，那么最后指针相遇的地方就是相交的第一个结点了。这个算法只用了常数个变量，空间复杂度达到 *O(1)*。</p><p>对应代码稍微花点时间，也能实现出来，但是真的就这一种情况吗？</p><p>其实这道题隐藏着一个陷阱：单链表可能存在<strong>环</strong>。因为环的存在，上述算法的第一步就执行不下去了，两个指针会在环内不停转圈。所以这道题必须分情况讨论。</p><img src="/2019/05/04/crossed-linkedlist/loop.png" class=""><p>既然考虑环，先来想想，一个链表有环，一个链表无环，它们可以相交吗？答案是否定的，还是受限于“单链表只有一个指针”的性质，我们无法画出这样的相交示意图来。</p><p>那么，只可能是两个链表都有环，于是画出下面这两张示意图。</p><img src="/2019/05/04/crossed-linkedlist/cross2.png" class="">        <img src="/2019/05/04/crossed-linkedlist/cross3.png" class=""><p>接下来需要区分一下这两种情况。可以发现：A 情况中两条链表<strong>由一个结点进环</strong>，而 B 情况的两条链表是<strong>分别进环</strong>的。于是我们在设计整个算法时，不仅仅要判断题目给出的两个链表是否有环，<strong>还要知道链表进环的第一个结点是什么</strong>。</p><p>于是我们设计一个 <code>getLoopNode()</code> 函数，当链表无环时，返回 <code>null</code>，否则返回进环的第一个结点。</p><p>首先要判断单链表有环，这是一个经典的题目，它的思路是：设置一个快指针和一个慢指针，快指针每次走两步，慢指针每次走一步，若快慢指针最终相遇，则链表有环，否则无环。就像以前数学课做的追及问题一样，跑道上有两个人同时在跑步，一个速度快，一个速度慢，跑得快的人总会追上慢的人。放在这里，链表中存在的环就是一个环绕操场的跑道，快慢指针总会在环中相遇。</p><p>接着来求进环的第一个结点。方法是：快慢指针相遇后，快指针回到自己链表的起点，和慢指针一起走，且两者每次都只走一步。当两个指针再次相遇时，相遇处就是环的第一个结点。</p><p>这个方法和它的结论似乎不可思议，我们用纯粹简单的数学证明一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">设一个单链表环外有 x (x∈N)个结点，环内有 y (y∈N*)个结点；</span><br><span class="line">快指针一次走两步，慢指针一次走一步，假设它们共同走了 k 步后相遇，</span><br><span class="line">此时快指针在环内走了 2k-x 步，慢指针在环内走了 k-x 步；</span><br><span class="line">既然它们可以相遇，那么必然有 (2k-x) mod y = (k-x) mod y；</span><br><span class="line">我们计算一下 2k-x 和 k-x 的差值，它一定是 y 的倍数，得到 k = ny(n∈N*)。</span><br><span class="line"></span><br><span class="line">快指针回到它的起点，再走到环的第一个结点，需要走 x+1 步，</span><br><span class="line">从快指针从起点出发到环的第一个结点，慢指针走了 (k-x) mod y + x + 1 步，</span><br><span class="line">那它就是在环内的第 [(k-x) mod y + x + 1] mod y 个结点处。</span><br><span class="line"></span><br><span class="line">设 k-x 和 y 相除的商是 A，余数是 a；</span><br><span class="line">设 (k-x) mod y + x + 1 和 y 相除的商是 B，余数是 b；</span><br><span class="line">有：Ay + a = k - x，By + b = a + x + 1；</span><br><span class="line">余数 b = a + x + 1 - By = (n - A - B)y + 1。</span><br><span class="line">一个数除以 y 的余数是 y 的整数倍再加上 1，很明显，n - A - B = 0。</span><br><span class="line"></span><br><span class="line">所以，慢指针此时在环的第一个结点处。</span><br></pre></td></tr></table></figure><p>思路和其原理都清楚了，我们就可以实现 <code>getLoopNode()</code> 函数了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title function_">getLoopNode</span><span class="params">(Node head)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 快指针</span></span><br><span class="line"><span class="type">Node</span> <span class="variable">n1</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">// 慢指针</span></span><br><span class="line"><span class="type">Node</span> <span class="variable">n2</span> <span class="operator">=</span> head.next.next;</span><br><span class="line"><span class="keyword">while</span> (n1 != n2) &#123;</span><br><span class="line"><span class="keyword">if</span> (n2.next == <span class="literal">null</span> || n2.next.next == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">n2 = n2.next.next;</span><br><span class="line">n1 = n1.next;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 快指针从头开始</span></span><br><span class="line">n2 = head;</span><br><span class="line"><span class="keyword">while</span> (n1 != n2) &#123;</span><br><span class="line">            <span class="comment">// 不相遇，则双方每次走一步</span></span><br><span class="line">n1 = n1.next;</span><br><span class="line">n2 = n2.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个链表调用一下上述的函数，得到两个结果 <code>loop1</code> 和 <code>loop2</code>，分别表示两个链表的环的第一个结点。</p><p>如果 <code>loop1</code> 和 <code>loop2</code> 都非空且相等，那么就对应情况 A。之前两个链表都无环的那种算法里，两个指针一起遍历到链表末尾停止才得到两个链表的长度，那这里只需要相应让两个指针遍历到 <code>loop1</code>（或者<code>loop2</code>），获得<strong>环前两个链表的长度</strong>，一样可以求得两个链表进环的第一个结点。</p><p>如果 <code>loop1</code> 和 <code>loop2</code> 都非空但是不等，那么除了情况 B 之外，这两个链表也有可能完全不相交，各自分离，如下所示。</p><img src="/2019/05/04/crossed-linkedlist/cross2.png" class=""> <p>那么假设一个指针从 <code>loop1</code> 开始走，在它再次走到 <code>loop1</code> 之前，若遇到了 <code>loop2</code> ，那么这两个链表是相交的，返回结果 <code>loop1</code> 或者 <code>loop2</code> 都可以；若该指针没有遇到  <code>loop2</code> ，那么两链表相离。</p><p>上述过程的代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title function_">bothLoop</span><span class="params">(Node head1, Node loop1, Node head2, Node loop2)</span> &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">cur1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">Node</span> <span class="variable">cur2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (loop1 == loop2) &#123;</span><br><span class="line">            <span class="comment">// 情况 A</span></span><br><span class="line">cur1 = head1;</span><br><span class="line">cur2 = head2;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">n++;</span><br><span class="line">cur1 = cur1.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (cur2 != loop2) &#123;</span><br><span class="line">n--;</span><br><span class="line">cur2 = cur2.next;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 较长链表的指针</span></span><br><span class="line">cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">            <span class="comment">// 较短链表的指针</span></span><br><span class="line">cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">n = Math.abs(n);</span><br><span class="line"><span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">n--;</span><br><span class="line">cur1 = cur1.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">cur1 = cur1.next;</span><br><span class="line">cur2 = cur2.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cur1;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cur1 = loop1.next;</span><br><span class="line"><span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line"><span class="keyword">if</span> (cur1 == loop2) &#123;</span><br><span class="line">                    <span class="comment">// 可以遇到 loop2，属于情况 B</span></span><br><span class="line"><span class="keyword">return</span> loop1;</span><br><span class="line">&#125;</span><br><span class="line">cur1 = cur1.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决此问题，千万不要想当然，而是要考虑多种情况，设计不同的算法。当然这其中也需要一定的经验积累。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;来看一道有关链表的题目：&lt;/p&gt;
&lt;p&gt;给定两个单链表的头结点 &lt;code&gt;head1&lt;/code&gt; 和 &lt;code&gt;head2&lt;/code&gt;，这两个链表可能相交，也可能不相交。请实现一个函数，若两链表相交，则返回相交的第一个结点；若不相交，则返回 &lt;code&gt;null&lt;/code&gt;。&lt;br&gt;进阶要求：如果链表1的长度为 &lt;em&gt;N&lt;/em&gt;，链表2的长度为 &lt;em&gt;M&lt;/em&gt;，时间复杂度请达到 *O(N+M)*，额外空间复杂度请达到 *O(1)*。&lt;/p&gt;
&lt;img src=&quot;/2019/05/04/crossed-linkedlist/cross1.png&quot; class=&quot;&quot;&gt;

&lt;p&gt;如上所示，根据题意可以立刻画出一个单链表相交的示意图。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>记第一次电话面试</title>
    <link href="http://yoursite.com/2019/04/26/first-interview/"/>
    <id>http://yoursite.com/2019/04/26/first-interview/</id>
    <published>2019-04-26T09:38:34.000Z</published>
    <updated>2022-04-21T12:08:03.866Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/04/26/first-interview/interview.png" class="" title="Photo by blog.devtang.com"><p>从寒假开始准备暑期实习后，整个三月都没有收到任何面试邀请，一些笔试结束后也杳无音讯了。</p><p>就在在四月快要结束的时候，上海<a href="https://www.duitang.com/">堆糖网</a>来了一个电话面试邀请。其实本来也准备放弃春招了，心态也比较佛，知道还有面试后又突然慌张起来，抱着<a href="https://github.com/Snailclimb/JavaGuide">面试指南</a>看了半天（在这里感谢 SnailClimb 大佬，真正惠及广大学生的项目）。</p><p>约的时间在我看完复联后的一个小时，找了家星巴克坐下等。一会儿电话来了。</p><span id="more"></span><p>先是问了问除了暑假，大四还可不可以去实习。</p><p>——肯定行啊（给 offer 就行啊）。</p><p>专业是物联网工程，当初为什么要选这个？</p><p>——“万物互联”很酷。我对这个回答不满意，其实还可以扯一点华为的 NB-IoT，那就有的聊了 :)（<strong>TODO：准备一点物联网的东西，可以和面试官扯上一阵子</strong>）</p><p>自我介绍。（准备了一点，但是觉得说的不自信，<strong>TODO：好好准备自我介绍</strong>）</p><p>Java 的 Object 类了解吗？</p><p>——所有类的父类。它有一些方法，（只想到了😥）hashcode()，toString()，notify()，notifyAll()。</p><p>那么和 hashCode() 相关的方法是什么？</p><p>——……不知道（是要让我讲HashMap吗？）</p><p>那你知道怎么判断两个对象是否相等呢？</p><p>——equals() 方法（原来是让我介绍这个啊）。（后来没往下说，其实应该扯一扯和“&#x3D;&#x3D;”的区别的，基础知识啊）</p><p>来问问数据结构吧。如何用两个栈实现一个队列？</p><p>——（这个题有印象的，应该做过。过于兴奋，一直在那边重复说话，语言组织能力降为0）push() 的话就是直接推进第一个栈里。pop() 就要取第一个的栈底了，可以一个个先放入第二个栈，把第二个栈栈顶 pop() 出去，再一个个推进第一个栈里，恢复原样就好了。</p><p>Spring MVC 的 DispatcherServlet 介绍一下。</p><p>——这个忘记了。应该是要我描述一下这张图：</p><img src="/2019/04/26/first-interview/ds.png" class="" title="Photo by https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_28817739&#x2F;article&#x2F;details&#x2F;80462837"><p><strong>TODO：此图一定牢记！</strong></p><p>来问问你的项目吧，是自己独立完成的吗，还是有学习教程？</p><p>——（实话实说）跟着教程走的，前端那些 JSP 是用的现成的，但是后台是自己实现的。</p><p>那好，说说项目里用到的 Filter 吧。</p><p>——（这个项目用的技术很古老了，可能看重 Web 开发基础吧）它就是个过滤器，之后我结合项目说了说我实际用它来干什么了，总结起来就是精简了 Servlet 类的编写。</p><p>来一个经典的问题吧：从在浏览器输入 URL 到显示网页，发生了什么呢？</p><p>——（这个问题之前笔试也有，好像还涉及到前端的很多知识，但我一个后端只能结合计网的知识来说了）从应用层到物理层往下将数据包封装，请求的发出和响应，blahblah……</p><p>好了先这样吧，你有什么问题要问我吗？</p><p>——对我印象如何？              ——中等……偏上吧。（凉……）</p><p>——我哪一块的知识欠缺？（帮我总结总结？）</p><p>——Object 类很常用，要熟悉；Spring 常用的框架要熟记（其实说了很多，但我没用耳机，还在商场，有点没听清，下次看见电话来了应该先戴上耳机的）</p><p>最后结束了我的第一次面试，一看时间，17 min，半小时也没有撑到，的确很多地方应该自己主动谈谈的，毕竟是展示自己的机会。</p><p>（语无伦次的）<strong>总结:</strong> 暑期实习有机会还是要争取，看大佬们在讨论着“互联网红利消失”等焦虑性话题，心里还是比较焦躁的。面试时首先找一个好的环境，不要像这次一样“喂？再说一遍好吗？”还好面试官脾气不错，这个真的很减分。自信一些，说话不要赶，知道的东西最好可以都说出来，多聊聊，也就是大家都建议的，“把面试话题引到自己熟悉的领域来”。加强自己的知识储备吧，这次的问题说实话应该全部完整回答出来，但是有可能是第一次面试比较紧张，我好像失去了冷静思考的能力😣。最后，也是最需要花时间改进的，做一两个真正上得了台面的项目，恶补一切专业知识。</p><p>好吧，这就是我的第一次面试了。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/2019/04/26/first-interview/interview.png&quot; class=&quot;&quot; title=&quot;Photo by blog.devtang.com&quot;&gt;

&lt;p&gt;从寒假开始准备暑期实习后，整个三月都没有收到任何面试邀请，一些笔试结束后也杳无音讯了。&lt;/p&gt;
&lt;p&gt;就在在四月快要结束的时候，上海&lt;a href=&quot;https://www.duitang.com/&quot;&gt;堆糖网&lt;/a&gt;来了一个电话面试邀请。其实本来也准备放弃春招了，心态也比较佛，知道还有面试后又突然慌张起来，抱着&lt;a href=&quot;https://github.com/Snailclimb/JavaGuide&quot;&gt;面试指南&lt;/a&gt;看了半天（在这里感谢 SnailClimb 大佬，真正惠及广大学生的项目）。&lt;/p&gt;
&lt;p&gt;约的时间在我看完复联后的一个小时，找了家星巴克坐下等。一会儿电话来了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="经验总结" scheme="http://yoursite.com/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>IDEA 使用技巧</title>
    <link href="http://yoursite.com/2019/03/15/IDEA-shortcut/"/>
    <id>http://yoursite.com/2019/03/15/IDEA-shortcut/</id>
    <published>2019-03-15T08:38:59.000Z</published>
    <updated>2022-04-21T12:08:03.849Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/03/15/IDEA-shortcut/theme.png" class="" title="Photo by code.org"><p>刚开始学习 Java 的时候，包括身边的同学都是在使用 Eclipse，后来在论坛看见有人大力推荐了 JetBrains 的 <a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a> ，使用后很快上手，不禁感叹这才是真正提高生产力的 IDE。在这里整理一些使用时积累的技巧经验。本文以 IntelliJ IDEA 2018.3.5 (Ultimate Edition) 为例进行介绍，不定期更新。</p><span id="more"></span><h2 id="代码自动补全（live-templates）"><a href="#代码自动补全（live-templates）" class="headerlink" title="代码自动补全（live templates）"></a>代码自动补全（live templates）</h2><p>在 IDEA 中使用“<strong>缩写 + Tab 键</strong>”实现代码快速补全，如下图可以实现快速输入“System.out.println();”：</p><img src="/2019/03/15/IDEA-shortcut/1.jpg" class="" title="Quick input"><p>使用 <strong>Ctrl + J</strong> 可以查看所有的 live templates 。下面列举一些常用的“缩写 + Tab 键”用法。</p><table><thead><tr><th align="center">缩写</th><th align="center">输出</th></tr></thead><tbody><tr><td align="center">sout</td><td align="center">System.out.println();</td></tr><tr><td align="center">psvm</td><td align="center">public static void main(String[] args) { }</td></tr><tr><td align="center">St</td><td align="center">String</td></tr><tr><td align="center">fori</td><td align="center">for (int i &#x3D; 0; i &lt; ; i++) { }</td></tr></tbody></table><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><table><thead><tr><th align="center">快捷键</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Alt + Ctrl + S</td><td align="center">打开设置</td></tr><tr><td align="center">Alt + Ctrl + Shift + S</td><td align="center">打开项目设置</td></tr><tr><td align="center">Alt + Enter</td><td align="center">快速修复</td></tr><tr><td align="center">Alt + Insert</td><td align="center">快速生成类构造方法、Getter、Setter 等</td></tr><tr><td align="center">Ctrl + mouse1</td><td align="center">转到类或方法的定义处</td></tr><tr><td align="center">Ctrl + X</td><td align="center">删除一行</td></tr><tr><td align="center">Ctrl + Alt + 左右方向键</td><td align="center">查看之前&#x2F;之后的光标定位处</td></tr></tbody></table><h2 id="主题更换"><a href="#主题更换" class="headerlink" title="主题更换"></a>主题更换</h2><p>在 <a href="http://color-themes.com/?view=index">Color Theme</a> 网站上选择喜欢的主题并下载保存到本地。然后在 IDEA 内点击 “**File —&gt; Import Settings… —&gt; 选择下载的 jar 包 —&gt; OK —&gt; Restart **”。然后按 <strong>Alt + Ctrl + S</strong> 快捷键进入设置，选择 <strong>Editor</strong> 下的 <strong>Color Scheme</strong> ，挑选主题名即可。</p><img src="/2019/03/15/IDEA-shortcut/2.jpg" class="" title="Change the theme"><h2 id="Git-操作"><a href="#Git-操作" class="headerlink" title="Git 操作"></a>Git 操作</h2><p>使用了 IDEA 以后，会导致你忘记所有 Git 命令。</p><p>开个玩笑。不过在 IDEA 里的 Git 的确集成得很好。要使用 Git，首先要在 Settings 里面搜索“Git”，然后设置好 “Path to Git executable” 这一项，也就是 git.exe 的目录。点击旁边的 “Test” 测试一下。</p><p>点击菜单栏的 VCS 的 “Create Git Repository” 可以创建一个 Git 项目。选中项目后右击，选择 Git 项可以进行 Add 或者 Commit 操作。</p><p>点击菜单栏的 VCS 的 “Share Project on GitHub” 可以将项目上传到你的 GitHub 中。</p><h2 id="推荐插件"><a href="#推荐插件" class="headerlink" title="推荐插件"></a>推荐插件</h2><p>IDEA 提供了许多官方支持的插件，当然你也可以在 Settings —&gt; Plugins —&gt; Marketplace 中寻找你需要的插件，还可以从互联上下载插件并导入。下面是几个常用的：</p><ol><li><strong>.ignore</strong> 在项目上传 GitHub 时，如 .idea 等本地配置文件是不需要，此插件帮你快速生成 .ignore 类文件。</li><li><strong>Alibaba Java Coding Guidelines</strong> 阿里巴巴代码规约，帮助检查你的代码是否规范，帮助形成良好的编码习惯，在 Marketplace 中直接搜索即可。</li><li><strong>Markdown Support</strong> 安装这个插件之后，打开 .md 文件就可以通过一个支持 Mrakdown 的视图查看和编辑内容。一般用于写 README.md 文件。</li></ol>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/2019/03/15/IDEA-shortcut/theme.png&quot; class=&quot;&quot; title=&quot;Photo by code.org&quot;&gt;

&lt;p&gt;刚开始学习 Java 的时候，包括身边的同学都是在使用 Eclipse，后来在论坛看见有人大力推荐了 JetBrains 的 &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt; ，使用后很快上手，不禁感叹这才是真正提高生产力的 IDE。在这里整理一些使用时积累的技巧经验。本文以 IntelliJ IDEA 2018.3.5 (Ultimate Edition) 为例进行介绍，不定期更新。&lt;/p&gt;</summary>
    
    
    
    
    <category term="经验总结" scheme="http://yoursite.com/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Cookie 与 Session</title>
    <link href="http://yoursite.com/2019/03/08/Cookie-Session/"/>
    <id>http://yoursite.com/2019/03/08/Cookie-Session/</id>
    <published>2019-03-08T12:43:05.000Z</published>
    <updated>2022-04-21T12:08:03.848Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/03/08/Cookie-Session/img.jpg" class="" title="Image from www.luo.net"><p>Servlet 的技术现在看来比较老旧，但是学好它的底层原理对于日后的框架学习非常有益。于是最近整理了一下其中 Cookie 与 Session 的相关知识，打好基础。</p><p>这两个东西的用处在哪里呢？想象在一个网上商城购物，你先在页面 A 挑选了几件商品，然后准备付款，跳入了新的页面 B ，这上面就有你刚刚所选的商品等信息。由于 HTTP 是<strong>无状态</strong>的，也就是说，你对于页面 A 的请求和页面 B 的之间没有关系，那这期间所产生的状态信息——也就是上面的选购商品——就必须保存下来。Cookie 与 Session 就来完成这个任务。</p><span id="more"></span><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie 是由服务器发送给客户端（浏览器）的<strong>大小有限</strong>的数据，以键值对的方式保存在客户端中。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li>浏览器向客户端发送请求；</li><li>服务器根据情况生成 Cookie 对象，将数据保存在该对象内；</li><li>把这个 Cookie 对象 放在 response 对象中，发回给客户端；</li><li>客户端接收到响应，在本地将 Cookie 保存；</li><li>再次请求服务器时，浏览器将其放进 request 中发送出去；</li><li>服务器取得 Cookie 信息。</li></ol><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>首先是 Cookie 的创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure><p>实际 Cookie 对象除了名称和值的属性外，还有域名、路径和有效期等，可以通过 <code>setDomain()</code> 、<code>setPath()</code> 和 <code>setMaxAge()</code> 等方法去设置。<br>假如想要销毁 Cookie 对象，就直接 <code>setMaxAge(0)</code> ，让其有效期为 0 即可。<br>然后是取出 Cookie 的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies();</span><br></pre></td></tr></table></figure><h3 id="关于-Cookie"><a href="#关于-Cookie" class="headerlink" title="关于 Cookie"></a>关于 Cookie</h3><ol><li>Cookie 可以保存一些用户登录时的账密码等，方便用户，好像是给用户尝了尝“甜头”，这也是其名字的由来。</li><li>Cookie 对象保存的数据必须是 String 类型的，其数量与大小都受到了限制；甚至用户也可以在浏览器里直接设置不使用 Cookie 功能。</li><li>Cookie 由于将数据保存在本地，很容易被篡改，造成安全问题。</li></ol><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Session 在服务端保存状态数据，这一点区别于 Cookie。</p><h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li>浏览器发出请求到服务器。</li><li>服务器首先检查这个客户端的请求里是否已包含了一个 Session 标识，即 Session ID：<br>(a) 如果有，那就根据 ID 将这个 Session 检索出来使用（检索不到会新建一个）；<br>(b) 如果没有，则服务端生成一个 Session 和对应的 Session ID。</li><li>接下来，服务器发回一个响应，将这个 ID 发给客户端保存，客户端一般使用 Cookie 保存。不过，客户端是可以禁用 Cookie 的，那么还可以用 URL 重写技术，在 URL 后面直接加上 ID 参数，当客户端再次发出请求时，服务器也可以取得 Session ID。</li><li>浏览器再次发出请求就会发送该 Session ID。</li><li>服务器得到这个 ID，找到对应的 Session 对象，取得数据。</li></ol><h3 id="实际应用-1"><a href="#实际应用-1" class="headerlink" title="实际应用"></a>实际应用</h3><p>创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession(<span class="literal">true</span>); </span><br></pre></td></tr></table></figure><p>对于第二条，如果 Session 不存在，则创建一个；假如写入 <code>false</code> 则在不存在 Session 时返回 <code>null</code> 。<br>还有一些常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getId</span><span class="params">()</span>;      <span class="comment">// 得到对象编号</span></span><br><span class="line">Object <span class="title function_">getAttribute</span><span class="params">(String name)</span>;     <span class="comment">// 返回对应名称的对象</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setMaxInactiveInterval</span><span class="params">(<span class="type">int</span> interval)</span>;      <span class="comment">//设置有效时长（单位为秒）</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">invalidate</span><span class="params">()</span>;         <span class="comment">// 手动销毁</span></span><br></pre></td></tr></table></figure><h3 id="关于-Session"><a href="#关于-Session" class="headerlink" title="关于 Session"></a>关于 Session</h3><p>Session 什么时候会被删除？</p><ol><li>Session超时，即在设定的时间内服务器未收到对应客户端的请求；</li><li>程序调用HttpSession.invalidate()；</li><li>服务器关闭或服务停止。</li></ol><p>另外，Session 会在一定时间内保存在服务器上。当访问增多，会比较占用服务器的性能。若要减轻服务器负担，应当使用 Cookie。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/2019/03/08/Cookie-Session/img.jpg&quot; class=&quot;&quot; title=&quot;Image from www.luo.net&quot;&gt;

&lt;p&gt;Servlet 的技术现在看来比较老旧，但是学好它的底层原理对于日后的框架学习非常有益。于是最近整理了一下其中 Cookie 与 Session 的相关知识，打好基础。&lt;/p&gt;
&lt;p&gt;这两个东西的用处在哪里呢？想象在一个网上商城购物，你先在页面 A 挑选了几件商品，然后准备付款，跳入了新的页面 B ，这上面就有你刚刚所选的商品等信息。由于 HTTP 是&lt;strong&gt;无状态&lt;/strong&gt;的，也就是说，你对于页面 A 的请求和页面 B 的之间没有关系，那这期间所产生的状态信息——也就是上面的选购商品——就必须保存下来。Cookie 与 Session 就来完成这个任务。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 51 &amp; 51：N-Queens 问题</title>
    <link href="http://yoursite.com/2019/02/20/leetcode-51-52/"/>
    <id>http://yoursite.com/2019/02/20/leetcode-51-52/</id>
    <published>2019-02-20T08:24:17.000Z</published>
    <updated>2022-04-21T12:08:03.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p><strong>题目链接</strong>：<a href="https://leetcode-cn.com/problems/n-queens/">N皇后</a> &amp; <a href="https://leetcode-cn.com/problems/n-queens-ii/">N皇后 II</a><br><strong>GitHub 导航</strong>：<a href="https://github.com/Avicii4/LeetCode/tree/master/problems/Math/N-Queens">https://github.com/Avicii4/LeetCode/tree/master/problems/Math/N-Queens</a></p><p><em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。如下图。</p><img src="/2019/02/20/leetcode-51-52/8-queens.png" class="" title="N皇后问题"><span id="more"></span><p>在国际象棋中，皇后可以说是移动最“自由”的棋子了，若无阻挡，她可以到达同一行、同一列或同一斜线方向上的任何一个位置。所以，题目中要求的“不能相互攻击”就是要让这些棋子<strong>不能同处一行、一列或一斜线上</strong>。<br>“N皇后”要求给定一个整数 <em>n</em>，返回所有不同的 <em>n</em> 皇后问题的解决方案。每一种解法包含一个明确的 <em>n</em> 皇后问题的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。<br>而“N皇后 II”题目给定一个整数 <em>n</em>，返回 <em>n</em> 皇后不同的解决方案的数量。<br>所以两道问题的设定没有变，可以一起解决。</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>这道题的基本思路是<strong>回溯法</strong>，这也是在 LeetCode 中比较常用的算法了。接下来描述一下本题的思路：</p><ol><li>算法开始, 清空棋盘，当前行设为第一行，当前列设为第一列；</li><li>在当前行，当前列的位置上判断是否满足条件，若不满足，跳到第4步；</li><li>在当前位置上满足条件的情形：<br> （1） 在当前位置放一个皇后，若当前行是最后一行，记录一个解；<br> （2） 若当前行不是最后一行，当前行设为下一行, 当前列设为当前行的第一个待测位置；<br> （3） 若当前行是最后一行，当前列不是最后一列，当前列设为下一列；<br> （4） 若当前行是最后一行，当前列是最后一列，回溯，即清空当前行及以下各行的棋盘，然后，当前行设为上一行，当前列设为当前行的下一个待测位置；<br> （5）以上返回到第2步；</li><li>在当前位置上不满足条件的情形：<br> （1） 若当前列不是最后一列，当前列设为下一列，返回到第2步;<br> （2） 若当前列是最后一列了，回溯，即，若当前行已经是第一行了，算法退出，否则，清空当前行及以下各行的棋盘，然后，当前行设为上一行，当前列设为当前行的下一个待测位置，返回到第2步。</li></ol><p>有了这个算法思路，接下来进行代码的编写。本来我考虑用二维数组存储每个棋子的位置坐标，这样也是大部分人第一时间想到的存储结构。不过，也可以用一个一维数组 <code>location[i]</code> 来存储位置信息，其中 <code>i</code> 是棋子所在的行数，<code>location[i]</code> 是棋子所在的列数。<br>再来看看怎么判断是位置否符合条件。一维数组每个位置代表一行，那么棋子在同一行的冲突情况肯定不会发生了；同一列方向上，检查数组中有没有其他地方与 <code>location[i]</code>的值一样；至于斜线方向，联系几何坐标系的内容，很容易知道两个位置的行数之差和列数之差的绝对值相等，则这两个棋子在同一斜线上。根据这个想法，写出方法 <code>isAttackable()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isAttackable</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span>[] location)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (location[row] == location[i] || Math.abs(location[row] - location[i]) == row - i)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>接下来的回溯过程用递归来实现，虽然损失了一定的效率，但简单易懂。递归的过程在完整代码中有所体现。</p><h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><p><strong>N皇后</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NQueens</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] location = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        insertQueen(n, <span class="number">0</span>, location, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertQueen</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> row, <span class="type">int</span>[] location, List&lt;List&lt;String&gt;&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123; <span class="comment">//当前行到达最后一行，构造结果</span></span><br><span class="line">            List&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j == location[i]) &#123;</span><br><span class="line">                        sb.append(<span class="string">&quot;Q&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        sb.append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                arrayList.add(sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(arrayList);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">//遍历所有列</span></span><br><span class="line">            location[row] = i;</span><br><span class="line">            <span class="keyword">if</span> (!isAttackable(row, location)) &#123;</span><br><span class="line">                insertQueen(n, row + <span class="number">1</span>, location, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isAttackable</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span>[] location)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="comment">// 判断棋子是否符合放置条件</span></span><br><span class="line">            <span class="keyword">if</span> (location[row] == location[i] || Math.abs(location[row] - location[i]) == row - i)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>提交结果</strong>：</p><img src="/2019/02/20/leetcode-51-52/res1.jpg" class="" title="提交结果1"><p><strong>N皇后II</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NQueensII</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//记录结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        check(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">int</span>[n]);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span>[] location)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (row == location.length) &#123; <span class="comment">//已找到一种解法</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; location.length; i++) &#123;</span><br><span class="line">            location[row] = i;</span><br><span class="line">            <span class="keyword">if</span> (!isAttackable(row, location)) &#123;</span><br><span class="line">                check(row + <span class="number">1</span>, location);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isAttackable</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span>[] location)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="comment">// 判断棋子放置的合法性</span></span><br><span class="line">            <span class="keyword">if</span> (location[row] == location[i] || Math.abs(location[row] - location[i]) == row - i)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>提交结果</strong> ：</p><img src="/2019/02/20/leetcode-51-52/res2.jpg" class="" title="提交结果2">]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目内容&quot;&gt;&lt;a href=&quot;#题目内容&quot; class=&quot;headerlink&quot; title=&quot;题目内容&quot;&gt;&lt;/a&gt;题目内容&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;题目链接&lt;/strong&gt;：&lt;a href=&quot;https://leetcode-cn.com/problems/n-queens/&quot;&gt;N皇后&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://leetcode-cn.com/problems/n-queens-ii/&quot;&gt;N皇后 II&lt;/a&gt;&lt;br&gt;&lt;strong&gt;GitHub 导航&lt;/strong&gt;：&lt;a href=&quot;https://github.com/Avicii4/LeetCode/tree/master/problems/Math/N-Queens&quot;&gt;https://github.com/Avicii4/LeetCode/tree/master/problems/Math/N-Queens&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;n&lt;/em&gt; 皇后问题研究的是如何将 &lt;em&gt;n&lt;/em&gt; 个皇后放置在 &lt;em&gt;n&lt;/em&gt;×&lt;em&gt;n&lt;/em&gt; 的棋盘上，并且使皇后彼此之间不能相互攻击。如下图。&lt;/p&gt;
&lt;img src=&quot;/2019/02/20/leetcode-51-52/8-queens.png&quot; class=&quot;&quot; title=&quot;N皇后问题&quot;&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>新年快乐</title>
    <link href="http://yoursite.com/2019/02/04/spring-festival-2019/"/>
    <id>http://yoursite.com/2019/02/04/spring-festival-2019/</id>
    <published>2019-02-04T15:23:08.000Z</published>
    <updated>2022-04-21T12:08:03.897Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/02/04/spring-festival-2019/img.jpg" class="" title="Photo by Sharosh Rajasekher on Unsplash"><p>又是一年辞旧迎新之时，又到了回顾与展望的时候了。<br>未来的一年对于我也充满了许多未知，可能是机遇，也可能是坎坷。好好把握，不断努力。<br>正如“爱范儿”公众号的一篇文章所说，“技术的世界就像西西弗斯，纵使岁月轮回却砥砺前行。”</p><p>那么，新的一年，继续加油。新年快乐。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/2019/02/04/spring-festival-2019/img.jpg&quot; class=&quot;&quot; title=&quot;Photo by Sharosh Rajasekher on Unsplash&quot;&gt;

&lt;p&gt;又是一年辞旧迎新之时，又到了回顾与展望的时候了。&lt;b</summary>
      
    
    
    
    
    <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 15：3Sum</title>
    <link href="http://yoursite.com/2019/01/24/leetcode-15/"/>
    <id>http://yoursite.com/2019/01/24/leetcode-15/</id>
    <published>2019-01-24T07:54:14.000Z</published>
    <updated>2022-04-21T12:08:03.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p><strong>题目链接</strong> ：<a href="https://leetcode-cn.com/problems/3sum/">三数之和</a><br><strong>GitHub 导航</strong>：<a href="https://github.com/Avicii4/LeetCode/tree/master/problems/Array/3Sum">https://github.com/Avicii4/LeetCode/tree/master/problems/Array/3Sum</a><br>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c &#x3D;</em> 0 ？找出所有满足条件且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。</p><span id="more"></span><p>例如, 给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>首先映入脑海的方法就是三重循环，把所有三数的组合取出来一一判断，但很明显这种方法的时间复杂度达到了可怕的 <em>O(n<sup>3</sup>)</em> ，定会报出超时错误，故不采用。<br>慢慢摸索其他解法。本题要求结果不含重复的元素，且每个三元组中的元素是升序排列的，故先将数组 <code>nums</code> 排序，方便排除重复项。接下来利用双指针法的思想，首先在头尾两个地方设置指针 <code>i</code> 和 <code>k</code> 并固定，再在中间设置一个变量 <code>j</code> ，移动寻找符合条件的数组元素。也就是设置变量 <code>i</code> 从头开始向后走，设置变量 <code>k</code> 从尾开始向前走，在它们中间找出符合的 <code>j</code> 值。示意图如下所示：</p><img src="/2019/01/24/leetcode-15/demo.png" class="" title="算法演示"><p>注意，循环过程中始终要保证这三个变量的<strong>相对位置不变</strong>，保证结果的正确性。<br>接下来考虑代码的优化。之前我们对数组进行了排序，若数组中有重复元素，应该立刻跳过，避免结果中出现重复项。变量 <code>i</code> 作为最外层循环，若 <code>nums[i] == nums[i - 1]</code> ，则可以直接 <code>continue</code> 跳过此次循环；对于变量 <code>j</code> 和 <code>k</code>，可以写出如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (j &lt; k &amp;&amp; nums[j] == nums[j + <span class="number">1</span>])</span><br><span class="line">    j++;</span><br><span class="line"><span class="keyword">while</span> (k &gt; j &amp;&amp; nums[k] == nums[k - <span class="number">1</span>])</span><br><span class="line">    k--;</span><br></pre></td></tr></table></figure><p>还有什么地方能优化？本题要求三数之和为0，如果和大于0，那么三数必定偏大，由于数组已经被置为升序，程序也就没有必要再向后寻找了；同样地，假如和为负数，三数必定偏小，因此：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sum &gt; <span class="number">0</span>)  k--;</span><br><span class="line"><span class="keyword">else</span>          j++;</span><br></pre></td></tr></table></figure><h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreeSum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[j] + nums[k];</span><br><span class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                    List&lt;Integer&gt; elem = Arrays.asList(nums[i], nums[k], nums[j]);</span><br><span class="line">                    result.add(elem);</span><br><span class="line">                    <span class="keyword">while</span> (j &lt; k &amp;&amp; nums[j] == nums[j + <span class="number">1</span>])</span><br><span class="line">                        j++;</span><br><span class="line">                    <span class="keyword">while</span> (k &gt; j &amp;&amp; nums[k] == nums[k - <span class="number">1</span>])</span><br><span class="line">                        k--;</span><br><span class="line">                    j++;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>)</span><br><span class="line">                    k--;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>提交结果</strong>：</p><img src="/2019/01/24/leetcode-15/submit.jpg" class="" title="提交结果">]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目内容&quot;&gt;&lt;a href=&quot;#题目内容&quot; class=&quot;headerlink&quot; title=&quot;题目内容&quot;&gt;&lt;/a&gt;题目内容&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;题目链接&lt;/strong&gt; ：&lt;a href=&quot;https://leetcode-cn.com/problems/3sum/&quot;&gt;三数之和&lt;/a&gt;&lt;br&gt;&lt;strong&gt;GitHub 导航&lt;/strong&gt;：&lt;a href=&quot;https://github.com/Avicii4/LeetCode/tree/master/problems/Array/3Sum&quot;&gt;https://github.com/Avicii4/LeetCode/tree/master/problems/Array/3Sum&lt;/a&gt;&lt;br&gt;给定一个包含 &lt;em&gt;n&lt;/em&gt; 个整数的数组 &lt;code&gt;nums&lt;/code&gt;，判断 &lt;code&gt;nums&lt;/code&gt; 中是否存在三个元素 &lt;em&gt;a，b，c ，&lt;/em&gt;使得 &lt;em&gt;a + b + c &amp;#x3D;&lt;/em&gt; 0 ？找出所有满足条件且不重复的三元组。&lt;br&gt;注意：答案中不可以包含重复的三元组。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>新增 Linux 系统调用</title>
    <link href="http://yoursite.com/2018/11/08/linux-kernel/"/>
    <id>http://yoursite.com/2018/11/08/linux-kernel/</id>
    <published>2018-11-08T12:28:35.000Z</published>
    <updated>2022-04-21T12:08:03.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>新增一个 Linux 系统调用，实现功能：计算一个数字三次方，并打印出来。<br>具体实现时有三个内容：</p><ul><li>需要重新编译 Linux 内核；</li><li>增加一个 Linux 的系统调用；</li><li>另外写一个程序进行调用。</li></ul><span id="more"></span><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>Windows 10 上 VMware Workstation 14 Pro，Ubuntu(64-bit) 18.04<br>原内核版本：4.15.0<br>编译内核版本：4.9.109<br>（<strong>注</strong>：若内核版本差距较大，在本文中涉及到的文件可能与实际不同）</p><h2 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h2><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>在 VMware Workstation 上安装 Ubuntu 操作系统。具体步骤可以看<a href="https://www.cnblogs.com/Alier/p/6337151.html#commentform">这里</a>。<br>要注意的是，在安装虚拟机前，给系统预留的磁盘空间应该为 <strong>40 GB 或更大</strong>，否则在解压缩内核文件或编译过程中都会报错。假如你的计算机是多核的，那可以相应地给虚拟机设置多个处理器，这会<strong>大大节约</strong>后面的内核编译时间。<br>   <img src="/2018/11/08/linux-kernel/1.png" class="" title="虚拟机设置"></p><p>装好系统后，开机，利用快捷键 <strong>Ctrl+Alt+T</strong> 打开终端。输入命令 <code>uname -a</code> ，查看该虚拟机系统的初始内核版本，这里是 <em>4.15.0</em>。<br>   <img src="/2018/11/08/linux-kernel/2.png" class="" title="查看初始内核版本"></p><p>在 <a href="http://www.kernel.org/">www.kernel.org</a> 上下载另外一个不同版本的内核，这里的版本号为 <em>4.9.109</em>。最好选择与初始版本<strong>接近</strong>的内核来编译。<br>用 <code>su</code> 命令进入 root，依次输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mv linux-4.9.109.tar.xz &#x27;/usr/src&#x27;</span><br><span class="line">mv &#x27;/usr/src&#x27;</span><br><span class="line">xz -d &#x27;/usr/src/linux-4.9.109.tar.xz&#x27;</span><br><span class="line">tar -xv -f &#x27;/usr/src/linux-4.9.109.tar&#x27; </span><br></pre></td></tr></table></figure><p>来<strong>移动</strong>并且<strong>解压缩</strong>我们下载的内核文件。<br>于是我们得到了 Linux 的内核文件，接下来的操作都在此文件夹（*&#x2F;usr&#x2F;src&#x2F;linux-4.9.109*）中进行。<br>   <img src="/2018/11/08/linux-kernel/3.png" class="" title="内核文件"></p><h3 id="添加系统调用"><a href="#添加系统调用" class="headerlink" title="添加系统调用"></a>添加系统调用</h3><p>接下来是修改内核文件。用 gedit 文本编辑器修改 <em>kernel&#x2F;sys.c</em> 文件，先是加入 <em>linkage.h</em> 头文件：</p><img src="/2018/11/08/linux-kernel/4.png" class="" title="添加头文件"><p>然后加入系统调用函数，注意要绕过条件编译，也就是 <code>#</code> 间的内容：</p><img src="/2018/11/08/linux-kernel/5.png" class="" title="系统调用函数"><p>修改好了，保存关闭文件。</p><p>用 gedit 文本编辑器修改 <em>arch&#x2F;x86&#x2F;include&#x2F;asm&#x2F;syscalls.h</em> 文件，添加系统调用函数的声明，保存并关闭。如下图：</p><img src="/2018/11/08/linux-kernel/6.png" class="" title="添加声明"><p>用 gedit 文本编辑器打开 <em>arch&#x2F;x86&#x2F;entry&#x2F;syscalls&#x2F;syscall_64.tbl</em> 文件，由于安装了64位系统，所以修改此文件。发现文件中的系统调用编号到 <em>331</em>为止，于是添上 <em>332</em> 号，注意<strong>不可以抢占</strong>其他已经存在的调用号，按照文件开头注释中标注的 “<number> <abi> <name> <entry point>” 格式加入新增内容，如下图所示：</p><img src="/2018/11/08/linux-kernel/7.png" class="" title="添加调用号"><h3 id="配置和编译内核"><a href="#配置和编译内核" class="headerlink" title="配置和编译内核"></a>配置和编译内核</h3><p>首先配置编译环境，在 root 状态下输入以下四条命令，安装编译所必要的软件包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libncurses5-dev libssl-dev</span><br><span class="line">apt-get install build-essential openssl</span><br><span class="line">apt-get install zlibc minizip</span><br><span class="line">apt-get install libidn11-dev libidn11</span><br></pre></td></tr></table></figure><p>如果在安装过程中出现错误，可以输入 <code>apt-get update</code> 命令更新，再继续安装。</p><p>如果是第一次编译，那就使用 <code>make menuconfig</code> 进入配置菜单（如下图），否则输入 <code>make mrproper</code> 清除之前的编译配置。<br>   <img src="/2018/11/08/linux-kernel/8.png" class="" title="配置菜单"></p><p>直接选择默认配置选项，使用键盘上的方向键选择 Exit 退出保存即可。<br>   <img src="/2018/11/08/linux-kernel/9.png" class="" title="保存退出"></p><p>接下来开始<strong>编译内核</strong>，命令为 <code>make</code> ，如果在第一步时给虚拟机设置了多个内核，则可以在后面加上 <code>-j*</code> （<code>*</code>  表示内核个数），可以加快编译速度。如果不知道系统的内核数量，使用命令 <code>lscpu</code> 查看，可以看见我这里的系统是双核。<br>   <img src="/2018/11/08/linux-kernel/10.png" class="" title="查看内核数量"></p><p>在编译过程中，要随时注意报错提示，及时解决。不过假如之前的步骤没有做错，大概率是没有错误的。如果有，请善用搜索引擎。<br>编译时间视机器性能而定。漫长的编译结束后，使用 <code>make modules_install</code> 和 <code>make install</code> 两个命令<strong>安装内核模块和内核</strong>。</p><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>重启系统，在开机时的虚拟机模式下，不停地按 <strong>Shift</strong> 进入 BIOS 界面：<br>   <img src="/2018/11/08/linux-kernel/11.png" class="" title="BIOS"></p><p>选择第二个高级选项，这里可以看见我们的新内核了！选择进入新编译好的内核版本 <em>4.9.109</em>：<br>   <img src="/2018/11/08/linux-kernel/12.png" class="" title="选择新内核"></p><p>在终端里再次查看内核，已经是更新后的版本了：<br>   <img src="/2018/11/08/linux-kernel/13.png" class="" title="内核已经更新"></p><p>编写一个测试程序，其中的 <em>332</em> 就是系统调用号，后面的 <code>3</code> 是传入的参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> t=syscall(<span class="number">332</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>gcc-o my test.c</code> 命令编译程序，使用 <code>./my</code> 命令运行，结果如下：<br>   <img src="/2018/11/08/linux-kernel/14.png" class="" title="结果"></p><p>计算结果正确！你还可以继续修改传入的参数反复验证结果。</p><p>到这里，我们就成功地添加了一个 Linux 的系统调用。</p><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><ol><li><a href="https://blog.csdn.net/Xiaobai__Lee/article/details/72048829">ubuntu16.04系统下的kernel 4.10的内核编译以及新增系统调用</a></li><li><a href="https://segmentfault.com/a/1190000007240700">Linux添加系统调用</a></li><li><a href="https://linux.cn/article-9665-1.html">如何编译 Linux 内核</a></li><li><a href="https://www.kernel.org/doc/html/v4.14/process/adding-syscalls.html">Adding a New System Call</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;新增一个 Linux 系统调用，实现功能：计算一个数字三次方，并打印出来。&lt;br&gt;具体实现时有三个内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要重新编译 Linux 内核；&lt;/li&gt;
&lt;li&gt;增加一个 Linux 的系统调用；&lt;/li&gt;
&lt;li&gt;另外写一个程序进行调用。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
    <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/11/06/hello-world/"/>
    <id>http://yoursite.com/2018/11/06/hello-world/</id>
    <published>2018-11-06T12:00:35.000Z</published>
    <updated>2022-04-21T12:08:03.869Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/11/06/hello-world/img.jpg" class="" title="Photo by Federica Galli on Unsplash"><p>欢迎来到我的博客主页！此博客由 <a href="https://hexo.io/">Hexo</a> 搭建，并且配以 <a href="https://github.com/litten/hexo-theme-yilia">Yilia</a> 主题。</p><p>出于对建站技术的好奇，我建立了这个基于 <a href="https://pages.github.com/">GitHub Pages</a> 的博客，用来记录我的学习所得和开发经历，偶尔也会写点关于自己兴趣的东西和生活琐碎。</p><p>有这么一个完全在自己掌控中的博客平台真是个不错的体验。好，那就从这里开始吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/2018/11/06/hello-world/img.jpg&quot; class=&quot;&quot; title=&quot;Photo by Federica Galli on Unsplash&quot;&gt;

&lt;p&gt;欢迎来到我的博客主页！此博客由 &lt;a href=&quot;https://hexo.i</summary>
      
    
    
    
    
    <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
